{% extends "base.html" %}

{% block title %}Autoscaling - {{ server.name }} - AI4K8s{% endblock %}

{% block head %}
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<style>
/* Professional Loading Indicator Styles */
.recommendation-loader {
    width: 100%;
    max-width: 500px;
    margin: 0 auto;
    padding: 2rem;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-lg);
}

.loader-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 1.5rem;
}

.loader-title {
    font-size: 0.9375rem;
    font-weight: 600;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.loader-status {
    font-size: 0.8125rem;
    color: var(--text-secondary);
    font-weight: 500;
}

.loader-animation {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 1.5rem;
    height: 60px;
}

.loader-spinner {
    width: 48px;
    height: 48px;
    position: relative;
}

.loader-spinner-ring {
    position: absolute;
    width: 48px;
    height: 48px;
    border: 3px solid transparent;
    border-top: 3px solid var(--primary-color);
    border-right: 3px solid var(--primary-color);
    border-radius: 50%;
    animation: loaderSpin 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
}

.loader-spinner-ring:nth-child(2) {
    width: 36px;
    height: 36px;
    top: 6px;
    left: 6px;
    border-top-color: var(--accent-color);
    border-right-color: var(--accent-color);
    animation-duration: 0.9s;
    animation-direction: reverse;
}

.loader-spinner-ring:nth-child(3) {
    width: 24px;
    height: 24px;
    top: 12px;
    left: 12px;
    border-top-color: var(--success-color);
    border-right-color: var(--success-color);
    animation-duration: 0.6s;
}

@keyframes loaderSpin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.loader-progress-container {
    width: 100%;
    margin-bottom: 1rem;
}

.loader-progress-bar {
    width: 100%;
    height: 8px;
    background: var(--border);
    border-radius: 4px;
    overflow: hidden;
    position: relative;
}

.loader-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
    border-radius: 4px;
    transition: width 0.3s ease-out;
    position: relative;
    overflow: hidden;
}

.loader-progress-fill::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    animation: progressShine 2s infinite;
}

@keyframes progressShine {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

.loader-progress-text {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 0.5rem;
    font-size: 0.8125rem;
}

.loader-progress-percentage {
    font-weight: 600;
    color: var(--primary-color);
}

.loader-progress-time {
    color: var(--text-muted);
    font-size: 0.75rem;
}

.loader-message {
    text-align: center;
    font-size: 0.875rem;
    color: var(--text-secondary);
    font-weight: 500;
    min-height: 1.5rem;
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(-5px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.loader-status-icon {
    width: 20px;
    height: 20px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

.loader-status-icon.processing {
    width: 16px;
    height: 16px;
    border: 2px solid var(--primary-color);
    border-top-color: transparent;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

.loader-status-icon.completed {
    width: 16px;
    height: 16px;
    background: var(--success-color);
    border-radius: 50%;
    position: relative;
}

.loader-status-icon.completed::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 6px;
    height: 3px;
    border: 2px solid white;
    border-top: none;
    border-right: none;
    transform: translate(-50%, -60%) rotate(-45deg);
}

.loader-status-icon.failed {
    width: 16px;
    height: 16px;
    background: var(--error-color);
    border-radius: 50%;
    position: relative;
}

.loader-status-icon.failed::before,
.loader-status-icon.failed::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 10px;
    height: 2px;
    background: white;
    transform: translate(-50%, -50%) rotate(45deg);
}

.loader-status-icon.failed::after {
    transform: translate(-50%, -50%) rotate(-45deg);
}

@keyframes spin {
    to { transform: rotate(360deg); }
}
</style>
{% endblock %}

{% block content %}
<div class="d-grid" style="grid-template-columns: 1fr; gap: 2rem;">
    <!-- Header -->
    <div class="d-flex justify-content-between align-items-center">
        <div>
            <h1 style="font-size: 2rem; font-weight: 700; color: var(--text-primary); margin-bottom: 0.5rem;">AI-Powered Autoscaling</h1>
            <p class="text-muted">Intelligent resource scaling for {{ server.name }}</p>
        </div>
        <div class="d-flex gap-2">
            <a href="/dashboard" class="btn btn-secondary">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 0.5rem;">
                    <path d="M3 9L12 2L21 9V20C21 20.5304 20.7893 21.0391 20.4142 21.4142C20.0391 21.7893 19.5304 22 19 22H5C4.46957 22 3.96086 21.7893 3.58579 21.4142C3.21071 21.0391 3 20.5304 3 20V9Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                Back to Dashboard
            </a>
            <button onclick="manualRefresh()" class="btn btn-primary">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 0.5rem;">
                    <path d="M1 4V10H7M23 20V14H17M20.49 9A9 9 0 0 0 5.64 5.64L9 9M3.51 15A9 9 0 0 0 18.36 18.36L15 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                Refresh
            </button>
        </div>
    </div>

    <!-- Overview Cards - First Row: Autoscaling Stats -->
    <div class="d-grid" style="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; margin-bottom: 1.5rem;">
        <div class="card">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <h3 style="font-size: 2rem; font-weight: 700; color: var(--primary-color); margin-bottom: 0.25rem;" id="hpa-count">-</h3>
                        <p class="text-muted mb-0">Active HPAs</p>
                    </div>
                    <div style="width: 3rem; height: 3rem; background: rgb(37 99 235 / 0.1); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="var(--primary-color)">
                            <path d="M8 6H16V14H8V6Z"/>
                            <path d="M16 6H20V10H16V6Z"/>
                            <path d="M8 14H16V18H8V14Z"/>
                            <path d="M16 14H20V18H16V14Z"/>
                        </svg>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <h3 style="font-size: 2rem; font-weight: 700; color: var(--success-color); margin-bottom: 0.25rem;" id="predictive-enabled">-</h3>
                        <p class="text-muted mb-0">Predictive Enabled</p>
                    </div>
                    <div style="width: 3rem; height: 3rem; background: rgb(16 185 129 / 0.1); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="var(--success-color)">
                            <path d="M9 12L11 14L15 10M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <h3 style="font-size: 2rem; font-weight: 700; color: var(--info-color); margin-bottom: 0.25rem;" id="scheduled-count">-</h3>
                        <p class="text-muted mb-0">Scheduled Rules</p>
                    </div>
                    <div style="width: 3rem; height: 3rem; background: rgb(14 165 233 / 0.1); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="var(--info-color)">
                            <path d="M12 8V12L15 15M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <h3 style="font-size: 2rem; font-weight: 700; color: var(--warning-color); margin-bottom: 0.25rem;" id="total-replicas">-</h3>
                        <p class="text-muted mb-0">Total Replicas</p>
                    </div>
                    <div style="width: 3rem; height: 3rem; background: rgb(245 158 11 / 0.1); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="var(--warning-color)">
                            <path d="M12 2L2 7L12 12L22 7L12 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M2 17L12 22L22 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M2 12L12 17L22 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <h3 style="font-size: 2rem; font-weight: 700; color: #8b5cf6; margin-bottom: 0.25rem;" id="vpa-count">-</h3>
                        <p class="text-muted mb-0">Active VPAs</p>
                    </div>
                    <div style="width: 3rem; height: 3rem; background: rgb(139 92 246 / 0.1); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="#8b5cf6">
                            <path d="M4 6H20V18H4V6Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M8 6V4C8 3.46957 8.21071 2.96086 8.58579 2.58579C8.96086 2.21071 9.46957 2 10 2H14C14.5304 2 15.0391 2.21071 15.4142 2.58579C15.7893 2.96086 16 3.46957 16 4V6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M12 10V14M12 6V8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Resource Usage Cards - Second Row: CPU & Memory (50% width each) -->
    <div class="d-grid" style="grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 1.5rem;">
        <div class="card">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <h3 style="font-size: 2rem; font-weight: 700; color: #ef4444; margin-bottom: 0.25rem;" id="cluster-cpu-usage">-</h3>
                        <p class="text-muted mb-0">CPU Usage</p>
                    </div>
                    <div style="width: 3rem; height: 3rem; background: rgb(239 68 68 / 0.1); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="#ef4444">
                            <path d="M12 2L2 7L12 12L22 7L12 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M2 17L12 22L22 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M2 12L12 17L22 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </div>
                </div>
                <div style="margin-top: 0.5rem;">
                    <div class="progress" style="height: 6px; background: #f3f4f6;">
                        <div id="cluster-cpu-progress" class="progress-bar" role="progressbar" style="width: 0%; background: #ef4444; transition: width 0.3s ease;"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <h3 style="font-size: 2rem; font-weight: 700; color: #3b82f6; margin-bottom: 0.25rem;" id="cluster-memory-usage">-</h3>
                        <p class="text-muted mb-0">Memory Usage</p>
                    </div>
                    <div style="width: 3rem; height: 3rem; background: rgb(59 130 246 / 0.1); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="#3b82f6">
                            <path d="M4 6H20V18H4V6Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M8 6V4C8 3.46957 8.21071 2.96086 8.58579 2.58579C8.96086 2.21071 9.46957 2 10 2H14C14.5304 2 15.0391 2.21071 15.4142 2.58579C15.7893 2.96086 16 3.46957 16 4V6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </div>
                </div>
                <div style="margin-top: 0.5rem;">
                    <div class="progress" style="height: 6px; background: #f3f4f6;">
                        <div id="cluster-memory-progress" class="progress-bar" role="progressbar" style="width: 0%; background: #3b82f6; transition: width 0.3s ease;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Predictive Autoscaling Section -->
    <div class="card">
        <div class="card-header">
            <h3 class="card-title">ü§ñ Predictive Autoscaling</h3>
            <small class="text-muted">AI-powered proactive scaling based on ML forecasts</small>
        </div>
        <div class="card-body">
            <div class="d-grid" style="grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 1.5rem;">
                <div>
                    <h4 style="margin-bottom: 1rem;">Forecast & Scaling</h4>
                    <div id="predictive-forecast-chart" style="height: 250px;">
                        <p class="text-muted text-center">No forecast data. Enable predictive autoscaling to see forecasts.</p>
                    </div>
                </div>
                <div>
                    <h4 style="margin-bottom: 1rem;">Enable Predictive Autoscaling</h4>
                    <form id="predictive-form" onsubmit="enablePredictiveAutoscaling(event)">
                        <div style="margin-bottom: 1rem;">
                            <label for="predictive-deployment" class="form-label">Deployment Name</label>
                            <input type="text" id="predictive-deployment" class="form-control" placeholder="my-app" required>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label for="predictive-namespace" class="form-label">Namespace</label>
                            <input type="text" id="predictive-namespace" class="form-control" value="default" required>
                        </div>
                        <div class="d-grid" style="grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                            <div>
                                <label for="predictive-min" class="form-label">Min Replicas</label>
                                <input type="number" id="predictive-min" class="form-control" value="2" min="1" required>
                            </div>
                            <div>
                                <label for="predictive-max" class="form-label">Max Replicas</label>
                                <input type="number" id="predictive-max" class="form-control" value="10" min="1" required>
                            </div>
                        </div>
                        <div style="margin-bottom: 1.5rem; padding: 1.25rem; background: linear-gradient(135deg, rgba(139, 92, 246, 0.05) 0%, rgba(59, 130, 246, 0.05) 100%); border-radius: 12px; border: 1px solid rgba(139, 92, 246, 0.15);">
                            <label for="predictive-state-management" class="form-label" style="font-weight: 600; color: var(--text-primary); margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: #8b5cf6;">
                                    <path d="M12 2L2 7L12 12L22 7L12 2Z"/>
                                    <path d="M2 17L12 22L22 17"/>
                                    <path d="M2 12L12 17L22 12"/>
                                </svg>
                                State Management
                                <span class="badge" style="background: rgba(139, 92, 246, 0.15); color: #8b5cf6; font-size: 0.7rem; font-weight: 500; padding: 0.25rem 0.5rem; border-radius: 6px; margin-left: auto;">
                                    Optional
                                </span>
                            </label>
                            <select id="predictive-state-management" class="form-select" style="
                                padding: 0.875rem 1rem;
                                font-size: 0.95rem;
                                border: 2px solid rgba(139, 92, 246, 0.2);
                                border-radius: 8px;
                                background: var(--surface);
                                color: var(--text-primary);
                                transition: all 0.2s ease;
                                cursor: pointer;
                                font-weight: 500;
                                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
                            " onmouseover="this.style.borderColor='rgba(139, 92, 246, 0.4)'; this.style.boxShadow='0 4px 8px rgba(139, 92, 246, 0.15)';" onmouseout="this.style.borderColor='rgba(139, 92, 246, 0.2)'; this.style.boxShadow='0 2px 4px rgba(0, 0, 0, 0.05)';" onfocus="this.style.borderColor='#8b5cf6'; this.style.boxShadow='0 4px 12px rgba(139, 92, 246, 0.25)';" onblur="this.style.borderColor='rgba(139, 92, 246, 0.2)'; this.style.boxShadow='0 2px 4px rgba(0, 0, 0, 0.05)';">
                                <option value="" style="font-weight: 500; padding: 0.5rem; background: var(--surface); color: var(--text-primary);">üîç Auto-detect (recommended)</option>
                                <option value="stateless" style="font-weight: 500; padding: 0.5rem; background: var(--surface); color: var(--text-primary);">‚ÜîÔ∏è Stateless (uses Redis/DB/external state) ‚Üí Prefer HPA</option>
                                <option value="stateful" style="font-weight: 500; padding: 0.5rem; background: var(--surface); color: var(--text-primary);">üìä Stateful (state inside pod) ‚Üí Prefer VPA</option>
                            </select>
                            <small class="form-text text-muted" style="font-size: 0.8rem; margin-top: 0.5rem; display: block; line-height: 1.5; color: var(--text-muted);">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 0.25rem;">
                                    <circle cx="12" cy="12" r="10"/>
                                    <path d="M12 16V12M12 8H12.01"/>
                                </svg>
                                Leave as "Auto-detect" to let the system analyze your deployment automatically from annotations, environment variables, and service dependencies.
                            </small>
                        </div>
                        <button type="submit" class="btn btn-primary" style="width: 100%;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 0.5rem;">
                                <path d="M9 12L11 14L15 10M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            Enable Predictive Autoscaling
                        </button>
                    </form>
                </div>
            </div>
            <!-- Enabled Deployments List -->
            <div id="predictive-deployments-list" style="margin-bottom: 1.5rem;">
                <!-- Will be populated by JavaScript -->
            </div>
            <!-- Recommendations - Full Width Below Grid -->
            <div style="width: 100%; margin-top: 1.5rem;">
                <h4 style="margin-bottom: 1rem;">Recommendations</h4>
                <div id="predictive-recommendations">
                    <p class="text-muted text-center">No recommendations available. Enable predictive autoscaling to get recommendations.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- HPA Management Section -->
    <div class="card">
        <div class="card-header">
            <h3 class="card-title">üìä Horizontal Pod Autoscaler (HPA)</h3>
            <small class="text-muted">Reactive autoscaling based on current metrics</small>
        </div>
        <div class="card-body">
            <div class="d-grid" style="grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                <div>
                    <h4 style="margin-bottom: 1rem;">Active HPAs</h4>
                    <div id="hpa-list" style="max-height: 400px; overflow-y: auto;">
                        <div class="loading">
                            <div class="spinner"></div>
                            Loading HPAs...
                        </div>
                    </div>
                </div>
                <div>
                    <h4 style="margin-bottom: 1rem;">Create New HPA</h4>
                    <form id="hpa-form" onsubmit="createHPA(event)">
                        <div style="margin-bottom: 1rem;">
                            <label for="hpa-deployment" class="form-label">Deployment Name</label>
                            <input type="text" id="hpa-deployment" class="form-control" placeholder="my-app" required>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label for="hpa-namespace" class="form-label">Namespace</label>
                            <input type="text" id="hpa-namespace" class="form-control" value="default" required>
                        </div>
                        <div class="d-grid" style="grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                            <div>
                                <label for="hpa-min" class="form-label">Min Replicas</label>
                                <input type="number" id="hpa-min" class="form-control" value="2" min="1" required>
                            </div>
                            <div>
                                <label for="hpa-max" class="form-label">Max Replicas</label>
                                <input type="number" id="hpa-max" class="form-control" value="10" min="1" required>
                            </div>
                        </div>
                        <div class="d-grid" style="grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                            <div>
                                <label for="hpa-cpu" class="form-label">CPU Target (%)</label>
                                <input type="number" id="hpa-cpu" class="form-control" value="70" min="1" max="100" required>
                            </div>
                            <div>
                                <label for="hpa-memory" class="form-label">Memory Target (%)</label>
                                <input type="number" id="hpa-memory" class="form-control" value="80" min="1" max="100" required>
                            </div>
                        </div>
                        <button type="submit" class="btn btn-primary" style="width: 100%;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 0.5rem;">
                                <path d="M12 5V19M5 12H19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            Create HPA
                        </button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- VPA Management Section -->
    <div class="card">
        <div class="card-header">
            <h3 class="card-title">üìà Vertical Pod Autoscaler (VPA)</h3>
            <small class="text-muted">Vertical scaling by adjusting CPU/Memory resources per pod</small>
        </div>
        <div class="card-body">
            <div class="d-grid" style="grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                <div>
                    <h4 style="margin-bottom: 1rem;">Active VPAs</h4>
                    <div id="vpa-list" style="max-height: 400px; overflow-y: auto;">
                        <div class="loading">
                            <div class="spinner"></div>
                            Loading VPAs...
                        </div>
                    </div>
                </div>
                <div>
                    <h4 style="margin-bottom: 1rem;">Create New VPA</h4>
                    <form id="vpa-form" onsubmit="createVPA(event)">
                        <div style="margin-bottom: 1rem;">
                            <label for="vpa-deployment" class="form-label">Deployment Name</label>
                            <input type="text" id="vpa-deployment" class="form-control" placeholder="my-app" required>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label for="vpa-namespace" class="form-label">Namespace</label>
                            <input type="text" id="vpa-namespace" class="form-control" value="default" required>
                        </div>
                        <div class="d-grid" style="grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                            <div>
                                <label for="vpa-min-cpu" class="form-label">Min CPU</label>
                                <input type="text" id="vpa-min-cpu" class="form-control" value="100m" placeholder="100m" required>
                            </div>
                            <div>
                                <label for="vpa-max-cpu" class="form-label">Max CPU</label>
                                <input type="text" id="vpa-max-cpu" class="form-control" value="1000m" placeholder="1000m" required>
                            </div>
                        </div>
                        <div class="d-grid" style="grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                            <div>
                                <label for="vpa-min-memory" class="form-label">Min Memory</label>
                                <input type="text" id="vpa-min-memory" class="form-control" value="128Mi" placeholder="128Mi" required>
                            </div>
                            <div>
                                <label for="vpa-max-memory" class="form-label">Max Memory</label>
                                <input type="text" id="vpa-max-memory" class="form-control" value="512Mi" placeholder="512Mi" required>
                            </div>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label for="vpa-update-mode" class="form-label">Update Mode</label>
                            <select id="vpa-update-mode" class="form-control" required>
                                <option value="Auto">Auto (VPA automatically updates pods)</option>
                                <option value="Recreate">Recreate (VPA recreates pods with new resources)</option>
                                <option value="Off">Off (VPA only provides recommendations)</option>
                            </select>
                        </div>
                        <button type="submit" class="btn btn-primary" style="width: 100%;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 0.5rem;">
                                <path d="M12 5V19M5 12H19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            Create VPA
                        </button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- Scheduled Autoscaling Section -->
    <div class="card">
        <div class="card-header">
            <h3 class="card-title">‚è∞ Scheduled Autoscaling</h3>
            <small class="text-muted">Time-based scaling based on historical patterns</small>
        </div>
        <div class="card-body">
            <div class="d-grid" style="grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                <div>
                    <h4 style="margin-bottom: 1rem;">Active Schedules</h4>
                    <div id="schedule-list" style="max-height: 300px; overflow-y: auto;">
                        <div class="loading">
                            <div class="spinner"></div>
                            Loading schedules...
                        </div>
                    </div>
                    <button onclick="analyzePatterns()" class="btn btn-secondary" style="width: 100%; margin-top: 1rem;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 0.5rem;">
                            <path d="M9 19C9 19.5304 9.21071 20.0391 9.58579 20.4142C9.96086 20.7893 10.4696 21 11 21H13C13.5304 21 14.0391 20.7893 14.4142 20.4142C14.7893 20.0391 15 19.5304 15 19M9 19C9 18.4696 9.21071 17.9609 9.58579 17.5858C9.96086 17.2107 10.4696 17 11 17H13C13.5304 17 14.0391 17.2107 14.4142 17.5858C14.7893 17.9609 15 18.4696 15 19M9 19H15M12 11V17M9 3V5M15 3V5M5 9H7M17 9H19M3 13H5M19 13H21M7 3H17C18.1046 3 19 3.89543 19 5V19C19 20.1046 18.1046 21 17 21H7C5.89543 21 5 20.1046 5 19V5C5 3.89543 5.89543 3 7 3Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        Analyze Historical Patterns
                    </button>
                </div>
                <div>
                    <h4 style="margin-bottom: 1rem;">Create Schedule</h4>
                    <form id="schedule-form" onsubmit="createSchedule(event)">
                        <div style="margin-bottom: 1rem;">
                            <label for="schedule-deployment" class="form-label">Deployment Name</label>
                            <input type="text" id="schedule-deployment" class="form-control" placeholder="my-app" required>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label for="schedule-namespace" class="form-label">Namespace</label>
                            <input type="text" id="schedule-namespace" class="form-control" value="default" required>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label for="schedule-time" class="form-label">Cron Expression</label>
                            <input type="text" id="schedule-time" class="form-control" placeholder="0 9 * * 1-5" required>
                            <small class="text-muted">Format: minute hour day month weekday (e.g., "0 9 * * 1-5" = 9 AM weekdays)</small>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <label for="schedule-replicas" class="form-label">Replicas</label>
                            <input type="number" id="schedule-replicas" class="form-control" value="5" min="1" required>
                        </div>
                        <button type="submit" class="btn btn-primary" style="width: 100%;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="margin-right: 0.5rem;">
                                <path d="M12 8V12L15 15M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            Create Schedule
                        </button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- Scaling History Chart -->
    <div class="card">
        <div class="card-header">
            <h3 class="card-title">üìà Scaling History & Predictions</h3>
        </div>
        <div class="card-body">
            <div id="scaling-history-chart" style="height: 400px; position: relative;">
                <canvas></canvas>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js?v=20260101"></script>
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js?v=20260101"></script>
<script>
console.log('üîçüîçüîç SCRIPT LOADED - autoscaling.html v20260101-3');
const serverId = {{ server.id | tojson }};
let charts = {};

// Show cluster disconnected message
function showClusterDisconnectedMessage(message) {
    let banner = document.getElementById('cluster-disconnected-banner');
    if (!banner) {
        banner = document.createElement('div');
        banner.id = 'cluster-disconnected-banner';
        banner.className = 'alert alert-danger';
        banner.style.cssText = 'margin-bottom: 2rem; padding: 1.5rem; border-left: 4px solid #ef4444; background: rgba(239, 68, 68, 0.1);';
        const content = document.querySelector('.d-grid');
        if (content) {
            content.insertBefore(banner, content.firstChild);
        }
    }
    banner.innerHTML = `
        <div class="d-flex align-items-center">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#ef4444" stroke-width="2" style="margin-right: 1rem;">
                <path d="M12 9V13M12 17H12.01M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <div>
                <strong style="color: #ef4444; font-size: 1.1rem;">‚ö†Ô∏è Cluster Disconnected</strong>
                <p class="mb-0 mt-1" style="color: #dc2626;">${message || 'Unable to connect to Kubernetes cluster. Please check your cluster configuration and ensure the cluster is running.'}</p>
            </div>
        </div>
    `;
}

// Manual refresh function - explicitly allows recommendation refresh
async function manualRefresh() {
    console.log('üîÑ Manual refresh triggered by user');
    lastManualRefreshTime = Date.now();
    await refreshAutoscaling(true); // Pass true to indicate manual refresh
}

// Load autoscaling status
async function refreshAutoscaling(allowRecommendationRefresh = false) {
    console.log(`üîÑ refreshAutoscaling called (allowRecommendationRefresh: ${allowRecommendationRefresh})`);
    try {
        const response = await fetch(`/api/autoscaling/status/${serverId}`);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const data = await response.json();
        console.log('üìä Autoscaling status data received:', data);
        console.log('üìä total_replicas:', data.total_replicas);
        console.log('üìä predictive_count:', data.predictive_count);
        console.log('üìä predictive_deployments:', data.predictive_deployments);
        
        // Check if cluster is disconnected
        if (data.error || data.cluster_disconnected) {
            const errorMsg = data.error || 'Cluster is not accessible';
            showClusterDisconnectedMessage(errorMsg);
            
            // Set all counts to 0
            document.getElementById('hpa-count').textContent = '0';
            document.getElementById('predictive-enabled').textContent = '0';
            document.getElementById('scheduled-count').textContent = '0';
            document.getElementById('total-replicas').textContent = '0';
            document.getElementById('vpa-count').textContent = '0';
            
            // Reset resource stats
            const cpuUsageEl = document.getElementById('cluster-cpu-usage');
            const memoryUsageEl = document.getElementById('cluster-memory-usage');
            const cpuProgressEl = document.getElementById('cluster-cpu-progress');
            const memoryProgressEl = document.getElementById('cluster-memory-progress');
            if (cpuUsageEl) cpuUsageEl.textContent = 'N/A';
            if (memoryUsageEl) memoryUsageEl.textContent = 'N/A';
            if (cpuProgressEl) cpuProgressEl.style.width = '0%';
            if (memoryProgressEl) memoryProgressEl.style.width = '0%';
            
            // Disable all forms
            document.querySelectorAll('form').forEach(form => {
                form.style.opacity = '0.5';
                form.style.pointerEvents = 'none';
            });
            
            return;
        }
        
        // Hide disconnected banner if cluster is connected
        const banner = document.getElementById('cluster-disconnected-banner');
        if (banner) banner.remove();
        
        // Re-enable forms
        document.querySelectorAll('form').forEach(form => {
            form.style.opacity = '1';
            form.style.pointerEvents = 'auto';
        });
        
        if (data.success) {
            console.log('‚úÖ Processing successful autoscaling status data');
            const hpaCountEl = document.getElementById('hpa-count');
            const predictiveEl = document.getElementById('predictive-enabled');
            const scheduledEl = document.getElementById('scheduled-count');
            const totalReplicasEl = document.getElementById('total-replicas');
            const vpaCountEl = document.getElementById('vpa-count');
            
            if (hpaCountEl) hpaCountEl.textContent = data.hpa_count || 0;
            if (predictiveEl) predictiveEl.textContent = data.predictive_count || 0;
            if (scheduledEl) scheduledEl.textContent = data.schedule_count || 0;
            if (vpaCountEl) vpaCountEl.textContent = data.vpa_count || 0;
            
            // Calculate total replicas: use backend-calculated total if available, otherwise sum HPAs
            let totalReplicas = 0;
            if (data.total_replicas !== undefined) {
                // Use backend-calculated total (includes HPAs + predictive deployments without HPA)
                totalReplicas = data.total_replicas;
            } else {
                // Fallback: sum HPA replicas only
                totalReplicas = (data.hpas || []).reduce((sum, hpa) => sum + (hpa.current_replicas || 0), 0);
            }
            if (totalReplicasEl) totalReplicasEl.textContent = totalReplicas;
            
            // Update real-time cluster resource stats (CPU & Memory Usage)
            const cpuUsageEl = document.getElementById('cluster-cpu-usage');
            const memoryUsageEl = document.getElementById('cluster-memory-usage');
            const cpuProgressEl = document.getElementById('cluster-cpu-progress');
            const memoryProgressEl = document.getElementById('cluster-memory-progress');
            
            if (data.current_metrics) {
                const cpuUsage = data.current_metrics.cpu_usage || 0;
                const memoryUsage = data.current_metrics.memory_usage || 0;
                
                // Update CPU usage
                if (cpuUsageEl) {
                    cpuUsageEl.textContent = cpuUsage.toFixed(1) + '%';
                    // Color code: green < 50%, yellow 50-80%, red > 80%
                    if (cpuUsage > 80) {
                        cpuUsageEl.style.color = '#ef4444';
                    } else if (cpuUsage > 50) {
                        cpuUsageEl.style.color = '#f59e0b';
                    } else {
                        cpuUsageEl.style.color = '#10b981';
                    }
                }
                if (cpuProgressEl) {
                    cpuProgressEl.style.width = Math.min(cpuUsage, 100) + '%';
                    // Update progress bar color
                    cpuProgressEl.className = 'progress-bar';
                    if (cpuUsage > 80) {
                        cpuProgressEl.style.background = '#ef4444';
                    } else if (cpuUsage > 50) {
                        cpuProgressEl.style.background = '#f59e0b';
                    } else {
                        cpuProgressEl.style.background = '#10b981';
                    }
                }
                
                // Update Memory usage
                if (memoryUsageEl) {
                    memoryUsageEl.textContent = memoryUsage.toFixed(1) + '%';
                    // Color code: green < 50%, yellow 50-80%, red > 80%
                    if (memoryUsage > 80) {
                        memoryUsageEl.style.color = '#ef4444';
                    } else if (memoryUsage > 50) {
                        memoryUsageEl.style.color = '#f59e0b';
                    } else {
                        memoryUsageEl.style.color = '#10b981';
                    }
                }
                if (memoryProgressEl) {
                    memoryProgressEl.style.width = Math.min(memoryUsage, 100) + '%';
                    // Update progress bar color
                    memoryProgressEl.className = 'progress-bar';
                    if (memoryUsage > 80) {
                        memoryProgressEl.style.background = '#ef4444';
                    } else if (memoryUsage > 50) {
                        memoryProgressEl.style.background = '#f59e0b';
                    } else {
                        memoryProgressEl.style.background = '#10b981';
                    }
                }
            } else {
                // No metrics available
                if (cpuUsageEl) cpuUsageEl.textContent = 'N/A';
                if (memoryUsageEl) memoryUsageEl.textContent = 'N/A';
                if (cpuProgressEl) cpuProgressEl.style.width = '0%';
                if (memoryProgressEl) memoryProgressEl.style.width = '0%';
            }
            
            console.log(`üìä Updating lists - HPAs: ${(data.hpas || []).length}, Schedules: ${(data.schedules || []).length}`);
            // Update HPA list
            updateHPAList(data.hpas || []);
            updateScheduleList(data.schedules || []);
            updatePredictiveDeploymentsList(data.predictive_deployments || []);
            updateVPAList(data.vpas || []);
            
            // Auto-load forecast for first enabled predictive deployment
            // IMPORTANT: Only load on initial page load or manual refresh, NOT on auto-refresh
            // This prevents excessive API calls and respects Groq rate limits
            if (data.predictive_deployments && data.predictive_deployments.length > 0) {
                const firstDeployment = data.predictive_deployments[0];
                
                // Check if we already have cached data for this deployment
                const hasCachedData = recommendationCache.data && 
                                    recommendationCache.deployment === firstDeployment.deployment_name &&
                                    recommendationCache.namespace === firstDeployment.namespace;
                
                // NEVER auto-refresh recommendations - completely disabled
                // This prevents excessive API calls and respects Groq rate limits
                // Recommendations ONLY refresh on manual Refresh button click
                
                // STRICT: Only load recommendations if explicitly allowed (manual refresh or initial load)
                // Check if this is truly the initial page load (no cache, never fetched, not a manual refresh)
                const isInitialLoad = !initialLoadDone && lastRecommendationFetchTime === 0 && !hasCachedData && !allowRecommendationRefresh;
                
                if (allowRecommendationRefresh) {
                    // Manual refresh - explicitly allowed
                    console.log(`üîÑ Manual refresh: Loading recommendations`);
                    loadPredictiveForecast(firstDeployment.deployment_name.trim(), (firstDeployment.namespace || 'default').trim(), true);
                } else if (hasCachedData) {
                    // Cached data exists - display it
                    console.log(`‚úÖ Cached recommendation available (auto-refresh completely disabled)`);
                    const chartContainer = document.getElementById('predictive-forecast-chart');
                    const recommendationsContainer = document.getElementById('predictive-recommendations');
                    if (chartContainer && recommendationsContainer && recommendationCache.data) {
                        displayRecommendations(recommendationCache.data, chartContainer, recommendationsContainer);
                    }
                } else if (isInitialLoad) {
                    // ONLY on initial page load (first time, no cache, never fetched)
                    console.log(`üîÑ Initial page load ONLY: Fetching recommendations (one-time)`);
                    loadPredictiveForecast(firstDeployment.deployment_name.trim(), (firstDeployment.namespace || 'default').trim(), false);
                } else {
                    // Not initial load and no cache - try to load anyway (might be a hard refresh)
                    console.log(`üîÑ No cache found, loading recommendations on page load`);
                    loadPredictiveForecast(firstDeployment.deployment_name.trim(), (firstDeployment.namespace || 'default').trim(), false);
                }
            } else {
                // No enabled deployments, show empty state
                const chartContainer = document.getElementById('predictive-forecast-chart');
                const recommendationsContainer = document.getElementById('predictive-recommendations');
                if (chartContainer) {
                    chartContainer.innerHTML = '<p class="text-muted text-center">No forecast data available. Enable predictive autoscaling for a deployment to see forecasts.</p>';
                }
                if (recommendationsContainer) {
                    recommendationsContainer.innerHTML = '<p class="text-muted text-center">No recommendations available. Enable predictive autoscaling to get recommendations.</p>';
                }
            }
        } else {
            // Handle error state - check if it's a disconnection error
            const errorMsg = data.error || 'Unknown error';
            if (data.cluster_disconnected || errorMsg.toLowerCase().includes('no such host') || errorMsg.toLowerCase().includes('connection refused') || errorMsg.toLowerCase().includes('unable to connect')) {
                showClusterDisconnectedMessage(errorMsg);
            }
            document.getElementById('hpa-count').textContent = '0';
            document.getElementById('predictive-enabled').textContent = '0';
            document.getElementById('scheduled-count').textContent = '0';
            document.getElementById('total-replicas').textContent = '0';
            document.getElementById('vpa-count').textContent = '0';
            updateHPAList([]);
            updateScheduleList([]);
            updatePredictiveDeploymentsList([]);
            updateVPAList([]);
            updateVPAList([]);
            
            // Clear forecast sections on error
            const chartContainer = document.getElementById('predictive-forecast-chart');
            const recommendationsContainer = document.getElementById('predictive-recommendations');
            if (chartContainer) {
                chartContainer.innerHTML = '<p class="text-muted text-center">No forecast data available. Enable predictive autoscaling for a deployment to see forecasts.</p>';
            }
            if (recommendationsContainer) {
                recommendationsContainer.innerHTML = '<p class="text-muted text-center">No recommendations available. Enable predictive autoscaling to get recommendations.</p>';
            }
        }
    } catch (error) {
        console.error('Error refreshing autoscaling:', error);
        // Check if it's a connection error
        const errorMsg = error.message || String(error);
        if (errorMsg.toLowerCase().includes('no such host') || errorMsg.toLowerCase().includes('connection refused') || errorMsg.toLowerCase().includes('unable to connect')) {
            showClusterDisconnectedMessage(errorMsg);
        }
        // Set fallback values
        document.getElementById('hpa-count').textContent = '0';
        document.getElementById('predictive-enabled').textContent = '0';
        document.getElementById('scheduled-count').textContent = '0';
        document.getElementById('total-replicas').textContent = '0';
        updateHPAList([]);
        updateScheduleList([]);
    }
}

function updateHPAList(hpas) {
    const container = document.getElementById('hpa-list');
    if (!container) {
        console.error('‚ùå hpa-list container not found');
        return;
    }
    if (!hpas || hpas.length === 0) {
        container.innerHTML = '<p class="text-muted">No HPAs configured</p>';
        return;
    }
    
    container.innerHTML = hpas.map(hpa => `
        <div class="card" style="margin-bottom: 1rem; padding: 1rem;">
            <div class="d-flex justify-content-between align-items-center">
                <div style="flex: 1;">
                    <h5 style="margin-bottom: 0.25rem;">${hpa.name}</h5>
                    <p class="text-muted mb-0" style="font-size: 0.875rem;">
                        Target: ${hpa.target} | 
                        Replicas: ${hpa.current_replicas}/${hpa.desired_replicas} | 
                        Range: ${hpa.min_replicas}-${hpa.max_replicas}
                    </p>
                </div>
                <div class="d-flex align-items-center gap-2">
                    <span class="badge ${hpa.status?.scaling_status === 'stable' ? 'badge-success' : 'badge-warning'}">
                        ${hpa.status?.scaling_status || 'unknown'}
                    </span>
                    <button class="btn btn-sm btn-danger" onclick="deleteHPA('${hpa.name}', '${hpa.namespace || 'default'}')" title="Delete HPA">
                        <i class="fas fa-trash"></i> Delete
                    </button>
                </div>
            </div>
        </div>
    `).join('');
}

function updateScheduleList(schedules) {
    const container = document.getElementById('schedule-list');
    if (!container) {
        console.error('‚ùå schedule-list container not found');
        return;
    }
    if (!schedules || schedules.length === 0) {
        container.innerHTML = '<p class="text-muted">No schedules configured</p>';
        return;
    }
    
    container.innerHTML = schedules.map(schedule => `
        <div class="card" style="margin-bottom: 1rem; padding: 1rem;">
            <div class="d-flex justify-content-between align-items-center">
                <div style="flex: 1;">
                    <h5 style="margin-bottom: 0.5rem;">${schedule.deployment_name}</h5>
                    <p class="text-muted mb-0" style="font-size: 0.875rem;">
                        ${schedule.rules_count || 0} schedule rules
                    </p>
                </div>
                <div>
                    <button class="btn btn-sm btn-danger" onclick="deleteSchedule('${schedule.deployment_name}', '${schedule.namespace || 'default'}')" title="Delete Schedule">
                        <i class="fas fa-trash"></i> Delete
                    </button>
                </div>
            </div>
        </div>
    `).join('');
}

function updatePredictiveDeploymentsList(deployments) {
    // Find or create container for predictive deployments list
    let container = document.getElementById('predictive-deployments-list');
    if (!container) {
        // Create container if it doesn't exist (should be in HTML, but create as fallback)
        const predictiveSection = document.querySelector('.predictive-autoscaling-section');
        if (predictiveSection) {
            container = document.createElement('div');
            container.id = 'predictive-deployments-list';
            container.style.marginTop = '1rem';
            predictiveSection.appendChild(container);
        } else {
            console.error('‚ùå Could not find predictive autoscaling section');
            return;
        }
    }
    
    // Filter out disabled deployments (safety check)
    const enabledDeployments = (deployments || []).filter(d => !d.disabled);
    
    if (!enabledDeployments || enabledDeployments.length === 0) {
        container.innerHTML = '<p class="text-muted">No predictive autoscaling enabled</p>';
        return;
    }
    
    container.innerHTML = `
        <div style="margin-bottom: 1rem;">
            <h5>Enabled Deployments</h5>
            ${enabledDeployments.map(deployment => `
                <div class="card" style="margin-bottom: 0.5rem; padding: 0.75rem;">
                    <div class="d-flex justify-content-between align-items-center">
                        <div style="flex: 1;">
                            <strong>${deployment.deployment_name}</strong>
                            <span class="text-muted" style="font-size: 0.875rem; margin-left: 0.5rem;">
                                (${deployment.namespace || 'default'})
                            </span>
                            <p class="text-muted mb-0" style="font-size: 0.75rem; margin-top: 0.25rem;">
                                Range: ${deployment.min_replicas || 2}-${deployment.max_replicas || 10} replicas
                            </p>
                        </div>
                        <div>
                            <button class="btn btn-sm btn-danger" onclick="disablePredictiveAutoscaling('${deployment.deployment_name}', '${deployment.namespace || 'default'}')" title="Disable Predictive Autoscaling">
                                <i class="fas fa-ban"></i> Disable
                            </button>
                        </div>
                    </div>
                </div>
            `).join('')}
        </div>
    `;
}

function updateVPAList(vpas) {
    const container = document.getElementById('vpa-list');
    if (!container) {
        console.error('‚ùå vpa-list container not found');
        return;
    }
    if (!vpas || vpas.length === 0) {
        container.innerHTML = '<p class="text-muted">No VPAs configured</p>';
        return;
    }
    
    container.innerHTML = vpas.map(vpa => {
        const recommendations = vpa.recommendations || [];
        const firstRec = recommendations.length > 0 ? recommendations[0] : null;
        return `
            <div class="card" style="margin-bottom: 1rem; padding: 1rem;">
                <div class="d-flex justify-content-between align-items-center">
                    <div style="flex: 1;">
                        <h5 style="margin-bottom: 0.5rem;">${vpa.name}</h5>
                        <p class="text-muted mb-1" style="font-size: 0.9rem;">
                            <strong>Target:</strong> ${vpa.target} | 
                            <strong>Mode:</strong> ${vpa.update_mode}
                        </p>
                        ${firstRec ? `
                            <p class="text-muted mb-1" style="font-size: 0.85rem;">
                                <strong>Recommended:</strong> CPU: ${firstRec.target_cpu || 'N/A'}, Memory: ${firstRec.target_memory || 'N/A'}
                            </p>
                        ` : ''}
                    </div>
                    <button class="btn btn-sm btn-danger" onclick="deleteVPA('${vpa.name}', '${vpa.namespace}')" style="margin-left: 1rem;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3 6H5H21M8 6V4C8 3.46957 8.21071 2.96086 8.58579 2.58579C8.96086 2.21071 9.46957 2 10 2H14C14.5304 2 15.0391 2.21071 15.4142 2.58579C15.7893 2.96086 16 3.46957 16 4V6M19 6V20C19 21.1046 18.1046 22 17 22H7C5.89543 22 5 21.1046 5 20V6H19Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                        Delete
                    </button>
                </div>
            </div>
        `;
    }).join('');
}

// Create HPA
async function createHPA(event) {
    event.preventDefault();
    const form = event.target;
    const data = {
        deployment_name: document.getElementById('hpa-deployment').value,
        namespace: document.getElementById('hpa-namespace').value,
        min_replicas: parseInt(document.getElementById('hpa-min').value),
        max_replicas: parseInt(document.getElementById('hpa-max').value),
        cpu_target: parseInt(document.getElementById('hpa-cpu').value),
        memory_target: parseInt(document.getElementById('hpa-memory').value)
    };
    
    try {
        const response = await fetch(`/api/autoscaling/hpa/create/${serverId}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(data)
        });
        const result = await response.json();
        
        if (result.success) {
            alert('HPA created successfully!');
            form.reset();
            refreshAutoscaling();
        } else {
            alert('Error: ' + (result.error || 'Failed to create HPA'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// Create VPA
async function createVPA(event) {
    event.preventDefault();
    const form = event.target;
    const data = {
        deployment_name: document.getElementById('vpa-deployment').value,
        namespace: document.getElementById('vpa-namespace').value,
        min_cpu: document.getElementById('vpa-min-cpu').value,
        max_cpu: document.getElementById('vpa-max-cpu').value,
        min_memory: document.getElementById('vpa-min-memory').value,
        max_memory: document.getElementById('vpa-max-memory').value,
        update_mode: document.getElementById('vpa-update-mode').value
    };
    
    try {
        const response = await fetch(`/api/autoscaling/vpa/create/${serverId}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(data)
        });
        const result = await response.json();
        
        if (result.success) {
            alert('VPA created successfully!');
            form.reset();
            refreshAutoscaling();
        } else {
            alert('Error: ' + (result.error || 'Failed to create VPA'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// Delete VPA
async function deleteVPA(vpaName, namespace) {
    if (!confirm(`Delete VPA "${vpaName}"?`)) {
        return;
    }
    
    try {
        const response = await fetch(`/api/autoscaling/vpa/delete/${serverId}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                vpa_name: vpaName,
                namespace: namespace
            })
        });
        const result = await response.json();
        
        if (result.success) {
            alert('VPA deleted successfully!');
            refreshAutoscaling();
        } else {
            alert('Error: ' + (result.error || 'Failed to delete VPA'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// Enable Predictive Autoscaling
async function enablePredictiveAutoscaling(event) {
    event.preventDefault();
    const form = event.target;
    const stateManagement = document.getElementById('predictive-state-management').value;
    const data = {
        deployment_name: document.getElementById('predictive-deployment').value,
        namespace: document.getElementById('predictive-namespace').value,
        min_replicas: parseInt(document.getElementById('predictive-min').value),
        max_replicas: parseInt(document.getElementById('predictive-max').value)
    };
    
    // Add state_management if user selected an option (not auto-detect)
    if (stateManagement) {
        data.state_management = stateManagement;
    }
    
    // Show loading indicator
    const enableButton = form.querySelector('button[type="submit"]');
    const originalButtonText = enableButton ? enableButton.innerHTML : '';
    if (enableButton) {
        enableButton.disabled = true;
        enableButton.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Enabling...';
    }
    
    // Show loading message in recommendations area
    const recommendationsContainer = document.getElementById('predictive-recommendations');
    if (recommendationsContainer) {
        recommendationsContainer.innerHTML = '<div class="recommendation-loader"><div class="loader-header"><div class="loader-title"><div class="loader-status-icon processing"></div><span>Enabling Predictive Autoscaling</span></div></div><div class="loader-animation"><div class="loader-spinner"><div class="loader-spinner-ring"></div><div class="loader-spinner-ring"></div><div class="loader-spinner-ring"></div></div></div><div class="loader-message">Initializing autoscaling engine and generating recommendations...</div></div>';
    }
    
    try {
        const response = await fetch(`/api/autoscaling/predictive/enable/${serverId}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(data)
        });
        const result = await response.json();
        
        // Restore button
        if (enableButton) {
            enableButton.disabled = false;
            enableButton.innerHTML = originalButtonText;
        }
        
        if (result.success) {
            // Success - no alert needed, loading indicator will show progress
            form.reset();
            refreshAutoscaling();
            // Clear cache and force refresh (user action, so allow it)
            recommendationCache = { data: null, timestamp: 0, deployment: null, namespace: null, lastMetrics: null };
            lastRecommendationFetchTime = 0; // Reset fetch time to allow immediate fetch
            isLoadingRecommendations = false; // Reset loading flag
            
            // Show loading indicator while fetching recommendations
            if (recommendationsContainer) {
                recommendationsContainer.innerHTML = '<div class="recommendation-loader"><div class="loader-header"><div class="loader-title"><div class="loader-status-icon processing"></div><span>Loading Recommendations</span></div></div><div class="loader-animation"><div class="loader-spinner"><div class="loader-spinner-ring"></div><div class="loader-spinner-ring"></div><div class="loader-spinner-ring"></div></div></div><div class="loader-message">Preparing recommendation engine...</div></div>';
            }
            
            loadPredictiveForecast(data.deployment_name, data.namespace, true);
        } else {
            // Show error in recommendations area
            if (recommendationsContainer) {
                recommendationsContainer.innerHTML = '<div class="alert alert-danger">Error: ' + (result.error || 'Failed to enable predictive autoscaling') + '</div>';
            }
            alert('Error: ' + (result.error || 'Failed to enable predictive autoscaling'));
        }
    } catch (error) {
        // Restore button on error
        if (enableButton) {
            enableButton.disabled = false;
            enableButton.innerHTML = originalButtonText;
        }
        
        // Show error in recommendations area
        if (recommendationsContainer) {
            recommendationsContainer.innerHTML = '<div class="alert alert-danger">Error: ' + error.message + '</div>';
        }
        alert('Error: ' + error.message);
    }
}

// Cache for recommendations to prevent rapid updates
let recommendationCache = {
    data: null,
    timestamp: 0,
    deployment: null,
    namespace: null,
    lastMetrics: null  // Store last metrics to detect significant changes
};
// Match backend rate limit: 5 minutes (300 seconds)
// This ensures we don't call the API more frequently than backend allows
const RECOMMENDATION_CACHE_TTL = 300000; // 300 seconds (5 minutes) - matches backend rate limit
const METRICS_CHANGE_THRESHOLD = 5; // Only refresh if metrics change by more than 5%

// Flag to prevent multiple simultaneous API calls
let isLoadingRecommendations = false;
let lastRecommendationFetchTime = 0; // Track when we last fetched recommendations
let initialLoadDone = false; // Global flag: initial load completed, block ALL automatic calls

// Track last manual refresh time to prevent any automatic calls
let lastManualRefreshTime = 0;

// Store current deployment for recommendation button
window.currentPredictiveDeployment = null;

// Load predictive forecast
async function loadPredictiveForecast(deployment, namespace, forceRefresh = false) {
    // Store for use in recommendation display
    window.currentPredictiveDeployment = { deployment_name: deployment, namespace: namespace };
    
    // STRICT GUARD: Only allow if forceRefresh is true (manual action) OR initial load (not done yet)
    const isManualAction = forceRefresh === true;
    const isInitialLoad = !initialLoadDone && lastRecommendationFetchTime === 0 && !isManualAction;
    
    // Block ALL automatic calls if initial load is done
    if (!isManualAction && initialLoadDone) {
        console.log('üö´ BLOCKED: Initial load done. Automatic refreshes disabled. Use Refresh button.');
        return;
    }
    
    // Block ALL automatic calls if not initial load
    if (!isManualAction && !isInitialLoad) {
        console.log('üö´ BLOCKED: Not initial load and not manual. Automatic refresh prevented.');
        return;
    }
    
    const chartContainer = document.getElementById('predictive-forecast-chart');
    const recommendationsContainer = document.getElementById('predictive-recommendations');
    
    // Prevent multiple simultaneous calls
    if (isLoadingRecommendations && !forceRefresh) {
        console.log('‚è∏Ô∏è Recommendation load already in progress, skipping...');
        return;
    }
    
    // Check cache with metrics stability check
    const now = Date.now();
    const cacheKey = `${deployment}/${namespace}`;
    const cacheAge = recommendationCache.timestamp > 0 ? (now - recommendationCache.timestamp) : Infinity;
    const timeSinceLastFetch = now - lastRecommendationFetchTime;
    
    // STRICT cache check - don't call API if cache is valid OR if we fetched recently
    if (!forceRefresh) {
        // Check 1: Cache is valid and for same deployment
        if (recommendationCache.deployment === deployment && 
            recommendationCache.namespace === namespace &&
            cacheAge < RECOMMENDATION_CACHE_TTL &&
            recommendationCache.data) {
            console.log(`‚úÖ Using cached recommendation (age: ${Math.round(cacheAge/1000)}s, TTL: ${RECOMMENDATION_CACHE_TTL/1000}s)`);
            displayRecommendations(recommendationCache.data, chartContainer, recommendationsContainer);
            return;
        }
        
        // Check 2: Rate limit - don't fetch if we fetched less than 5 minutes ago
        if (timeSinceLastFetch < RECOMMENDATION_CACHE_TTL && lastRecommendationFetchTime > 0) {
            console.log(`‚è∏Ô∏è Rate limiting: Only ${Math.round(timeSinceLastFetch/1000)}s since last fetch (min: ${RECOMMENDATION_CACHE_TTL/1000}s)`);
            // Use cached data if available, even if expired
            if (recommendationCache.data && recommendationCache.deployment === deployment) {
                displayRecommendations(recommendationCache.data, chartContainer, recommendationsContainer);
            }
            return;
        }
    }
    
    // Mark as loading
    isLoadingRecommendations = true;
    
    // Show loading state only if not already showing data
    if (!recommendationCache.data || forceRefresh) {
        chartContainer.innerHTML = '<div class="recommendation-loader"><div class="loader-header"><div class="loader-title"><div class="loader-status-icon processing"></div><span>Loading Forecast</span></div></div><div class="loader-animation"><div class="loader-spinner"><div class="loader-spinner-ring"></div><div class="loader-spinner-ring"></div><div class="loader-spinner-ring"></div></div></div><div class="loader-message">Preparing forecast data...</div></div>';
        recommendationsContainer.innerHTML = '<div class="recommendation-loader"><div class="loader-header"><div class="loader-title"><div class="loader-status-icon processing"></div><span>Loading Recommendations</span></div></div><div class="loader-animation"><div class="loader-spinner"><div class="loader-spinner-ring"></div><div class="loader-spinner-ring"></div><div class="loader-spinner-ring"></div></div></div><div class="loader-message">Preparing recommendation engine...</div></div>';
    }
    
    try {
        // Update fetch time BEFORE making the call
        const now = Date.now();
        lastRecommendationFetchTime = now;
        if (isManualAction) {
            lastManualRefreshTime = now;
            console.log('‚úÖ Manual refresh - allowed');
        } else if (isInitialLoad) {
            initialLoadDone = true; // Mark initial load as complete
            console.log('‚úÖ Initial load - allowed (one-time only, now blocking all automatic calls)');
        }
        
        // Trim deployment name and namespace to avoid whitespace issues
        const trimmedDeployment = deployment.trim();
        const trimmedNamespace = (namespace || 'default').trim();
        
        console.log(`üîÑ Starting async recommendation job for deployment: "${trimmedDeployment}" in namespace: "${trimmedNamespace}"`);
        
        // Step 1: Start async job - get job_id
        const url = `/api/autoscaling/recommendations/${serverId}?deployment=${encodeURIComponent(trimmedDeployment)}&namespace=${encodeURIComponent(trimmedNamespace)}`;
        console.log(`üì° API URL: ${url}`);
        
        const response = await fetch(url);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error(`‚ùå HTTP ${response.status} error:`, errorText);
            throw new Error(`HTTP ${response.status}: ${response.statusText}. ${errorText.substring(0, 200)}`);
        }
        
        const jobResponse = await response.json();
        console.log(`üìä Job created:`, jobResponse);
        
        // Check if we got a job_id (async) or direct result (sync fallback)
        let jobId = jobResponse.job_id;
        let data = null;
        
        if (jobId) {
            // Async mode: Use WebSocket for real-time updates
            console.log(`üîÑ Subscribing to job ${jobId} via WebSocket...`);
            
            // Fallback to polling function (defined first)
            async function fallbackToPolling(jobId) {
                let pollCount = 0;
                const maxPolls = 135;  // Increased to 135 polls (4.5 minutes at 2s interval) to accommodate Qwen's 240s timeout
                const pollInterval = 2000;
                
                while (pollCount < maxPolls) {
                    await new Promise(resolve => setTimeout(resolve, pollInterval));
                    pollCount++;
                    
                    try {
                        const statusUrl = `/api/autoscaling/recommendations/status/${jobId}`;
                        const statusResponse = await fetch(statusUrl);
                        
                        if (!statusResponse.ok) {
                            throw new Error(`Status check failed: ${statusResponse.statusText}`);
                        }
                        
                        const statusData = await statusResponse.json();
                        console.log(`üìä Poll ${pollCount}: Status = ${statusData.status}`);
                        
                        const loadingMsg = statusData.status === 'processing' 
                            ? `üîÑ Generating LLM recommendations... (${pollCount * 2}s)`
                            : statusData.status === 'completed'
                            ? '‚úÖ Processing results...'
                            : '‚è≥ Waiting for LLM...';
                        
                        if (recommendationsContainer) {
                            recommendationsContainer.innerHTML = `<div class="loading"><div class="spinner"></div>${loadingMsg}</div>`;
                        }
                        
                        if (statusData.status === 'completed') {
                            return statusData.result;
                        } else if (statusData.status === 'failed') {
                            throw new Error(statusData.error || 'Job failed');
                        }
                    } catch (error) {
                        console.error(`‚ùå Error polling job status:`, error);
                        throw error;
                    }
                }
                
                throw new Error('Job timed out after 4.5 minutes');
            }
            
            // WebSocket subscription with Promise-based waiting
            data = await new Promise((resolve, reject) => {
                console.log('üîç Promise: STARTING WebSocket subscription');
                let socket;
                let startTime = Date.now();
                let resolved = false;
                
                // Get recommendationsContainer at the start (use let so it can be reassigned if needed)
                let recommendationsContainer = document.getElementById('predictive-recommendations');
                console.log(`üîç Promise: recommendationsContainer=${!!recommendationsContainer}, element=${recommendationsContainer ? recommendationsContainer.id : 'null'}`);
                if (!recommendationsContainer) {
                    console.error('üîç Promise: ERROR - recommendationsContainer is null! Element may not exist in DOM.');
                    console.error('üîç Promise: Available elements:', document.querySelectorAll('[id*="recommendation"]'));
                }
                
                // Try WebSocket first
                try {
                    if (typeof io === 'undefined') {
                        console.warn('‚ö†Ô∏è Socket.IO not loaded, falling back to polling');
                        fallbackToPolling(jobId).then(resolve).catch(reject);
                        return;
                    }
                    
                    socket = io();
                    
                    socket.on('connect', () => {
                        console.log('üîå WebSocket connected');
                        socket.emit('subscribe_job', { job_id: jobId });
                    });
                    
                    // Store current status for timer updates
                    let currentStatus = { status: 'processing', progress: 0, message: 'Starting LLM analysis...' };
                    let elapsedTimer = null;
                    
                    // Track animated progress for smooth transitions
                    let animatedProgress = 0;
                    let targetProgress = 2; // Start at 2% immediately for visual feedback
                    let progressAnimationInterval = null;
                    
                    // Debounce mechanism to prevent too frequent updates
                    let lastUpdateTime = 0;
                    const UPDATE_THROTTLE_MS = 500; // Only update every 500ms max
                    
                    // Cache element references to avoid repeated querySelector calls
                    let cachedElements = {
                        loaderElement: null,
                        progressFill: null,
                        progressPercentage: null,
                        progressTime: null,
                        loaderStatus: null,
                        loaderMessage: null,
                        statusIcon: null
                    };
                    
                    // Function to update display with current elapsed time (define FIRST so it can be called by animateProgress)
                    const updateDisplay = () => {
                        // Throttle updates to prevent flashing
                        const now = Date.now();
                        if (now - lastUpdateTime < UPDATE_THROTTLE_MS && lastUpdateTime > 0) {
                            return; // Skip if called too soon (throttled)
                        }
                        lastUpdateTime = now;
                        
                        if (resolved) {
                            return;
                        }
                        if (!recommendationsContainer) {
                            return;
                        }
                        
                        const elapsed = Math.floor((Date.now() - startTime) / 1000);
                        const status = currentStatus.status;
                        const message = currentStatus.message || 'Analyzing deployment metrics and generating recommendations...';
                        
                        // Calculate progress: Use backend progress if available, otherwise time-based
                        let progress = 0;
                        
                        // FIRST: Use backend progress if available (from WebSocket updates)
                        if (currentStatus.progress !== undefined) {
                            progress = currentStatus.progress;
                        } else if (status === 'processing') {
                            // FALLBACK: Calculate progress based on elapsed time when processing
                            // This handles the case where backend hasn't sent progress yet
                            if (elapsed <= 0) {
                                progress = 1; // Show 1% immediately
                            } else if (elapsed < 5) {
                                progress = Math.max(2, Math.floor(elapsed)); // At least 2%, or elapsed seconds
                            } else if (elapsed < 10) {
                                progress = 5;
                            } else if (elapsed < 30) {
                                progress = 5 + Math.floor((elapsed - 10) / 20 * 25); // 5% to 30%
                            } else if (elapsed < 60) {
                                progress = 30 + Math.floor((elapsed - 30) / 30 * 30); // 30% to 60%
                            } else if (elapsed < 90) {
                                progress = 60 + Math.floor((elapsed - 60) / 30 * 30); // 60% to 90%
                            } else if (elapsed < 120) {
                                progress = 90 + Math.floor((elapsed - 90) / 30 * 5); // 90% to 95%
                            } else {
                                progress = 95;
                            }
                            
                            // Ensure minimum 1% progress when processing
                            progress = Math.max(1, progress);
                        } else {
                            // Use animatedProgress for completed/failed states
                            progress = Math.max(0, Math.min(100, Math.round(animatedProgress)));
                        }
                        
                        // If backend sent 0% but we're processing and time has passed, show time-based instead
                        if (status === 'processing' && currentStatus.progress === 0 && elapsed > 2) {
                            // Backend sent 0%, but time has passed - use time-based progress
                            if (elapsed < 5) {
                                progress = Math.max(2, Math.floor(elapsed));
                            } else if (elapsed < 10) {
                                progress = 5;
                            } else if (elapsed < 30) {
                                progress = 5 + Math.floor((elapsed - 10) / 20 * 25);
                            } else if (elapsed < 60) {
                                progress = 30 + Math.floor((elapsed - 30) / 30 * 30);
                            } else if (elapsed < 90) {
                                progress = 60 + Math.floor((elapsed - 60) / 30 * 30);
                            } else if (elapsed < 120) {
                                progress = 90 + Math.floor((elapsed - 90) / 30 * 5);
                            } else {
                                progress = 95;
                            }
                            progress = Math.max(1, progress);
                        }
                        
                        // Use animatedProgress if it's higher (for smooth animation)
                        const animated = Math.round(animatedProgress);
                        if (animated > progress) {
                            progress = animated;
                        }
                        
                        // Debug log
                        console.log(`üîç updateDisplay: elapsed=${elapsed}s, status=${status}, progress=${progress}%, animatedProgress=${animatedProgress.toFixed(1)}%`);
                        
                        let statusIcon = '<div class="loader-status-icon processing"></div>';
                        let statusText = 'Processing';
                        let statusClass = 'processing';
                        
                        if (status === 'completed') {
                            statusIcon = '<div class="loader-status-icon completed"></div>';
                            statusText = 'Completed';
                            statusClass = 'completed';
                        } else if (status === 'failed') {
                            statusIcon = '<div class="loader-status-icon failed"></div>';
                            statusText = 'Failed';
                            statusClass = 'failed';
                        }
                        
                        const timeDisplay = elapsed > 0 ? `${elapsed}s` : 'Starting...';
                        
                        // CRITICAL: Verify container exists before setting innerHTML
                        if (!recommendationsContainer) {
                            return;
                        }
                        
                        // Check if loader already exists - use cached elements or query DOM
                        // Only query DOM if cached elements are null or invalid (removed from DOM)
                        if (!cachedElements.loaderElement || !cachedElements.loaderElement.parentNode) {
                            cachedElements.loaderElement = recommendationsContainer.querySelector('.recommendation-loader');
                            cachedElements.progressFill = recommendationsContainer.querySelector('.loader-progress-fill');
                            cachedElements.progressPercentage = recommendationsContainer.querySelector('.loader-progress-percentage');
                            cachedElements.progressTime = recommendationsContainer.querySelector('.loader-progress-time');
                            cachedElements.loaderStatus = recommendationsContainer.querySelector('.loader-status');
                            cachedElements.loaderMessage = recommendationsContainer.querySelector('.loader-message');
                            cachedElements.statusIcon = recommendationsContainer.querySelector('.loader-status-icon');
                        }
                        
                        // ALWAYS try to update existing elements first to prevent flashing
                        if (cachedElements.loaderElement && cachedElements.progressFill && cachedElements.progressPercentage && cachedElements.progressTime) {
                            // Elements found in cache - update in place (NO innerHTML replacement = NO FLASHING)
                            // This path should be taken after first call
                            cachedElements.progressFill.style.width = `${progress}%`;
                            cachedElements.progressPercentage.textContent = `${progress}%`;
                            cachedElements.progressTime.textContent = timeDisplay;
                            if (cachedElements.loaderStatus) cachedElements.loaderStatus.textContent = statusText;
                            if (cachedElements.loaderMessage) {
                                cachedElements.loaderMessage.textContent = message;
                            }
                            // Update status icon if status changed
                            if (cachedElements.statusIcon) {
                                if (status === 'completed') {
                                    cachedElements.statusIcon.className = 'loader-status-icon completed';
                                } else if (status === 'failed') {
                                    cachedElements.statusIcon.className = 'loader-status-icon failed';
                                } else {
                                    cachedElements.statusIcon.className = 'loader-status-icon processing';
                                }
                            }
                            return; // CRITICAL: Skip innerHTML replacement to prevent flashing
                        }
                        
                        // Clear cache when creating new elements (they don't exist yet)
                        cachedElements = {
                            loaderElement: null,
                            progressFill: null,
                            progressPercentage: null,
                            progressTime: null,
                            loaderStatus: null,
                            loaderMessage: null,
                            statusIcon: null
                        };
                        
                        // First time only - create the entire structure
                        recommendationsContainer.innerHTML = `
                            <div class="recommendation-loader">
                                <div class="loader-header">
                                    <div class="loader-title">
                                        ${statusIcon}
                                        <span>Generating Recommendations</span>
                                    </div>
                                    <div class="loader-status">${statusText}</div>
                                </div>
                                
                                <div class="loader-animation">
                                    <div class="loader-spinner">
                                        <div class="loader-spinner-ring"></div>
                                        <div class="loader-spinner-ring"></div>
                                        <div class="loader-spinner-ring"></div>
                                    </div>
                                </div>
                                
                                <div class="loader-progress-container">
                                    <div class="loader-progress-bar">
                                        <div class="loader-progress-fill" style="width: ${progress}% !important; transition: width 0.2s linear;"></div>
                                    </div>
                                    <div class="loader-progress-text">
                                        <span class="loader-progress-percentage">${progress}%</span>
                                        <span class="loader-progress-time">${timeDisplay}</span>
                                    </div>
                                </div>
                                
                                <div class="loader-message">${message}</div>
                            </div>
                        `;
                        
                        // CRITICAL: Cache the newly created elements IMMEDIATELY after innerHTML
                        // This ensures they're found on subsequent calls to prevent flashing
                        cachedElements.loaderElement = recommendationsContainer.querySelector('.recommendation-loader');
                        cachedElements.progressFill = recommendationsContainer.querySelector('.loader-progress-fill');
                        cachedElements.progressPercentage = recommendationsContainer.querySelector('.loader-progress-percentage');
                        cachedElements.progressTime = recommendationsContainer.querySelector('.loader-progress-time');
                        cachedElements.loaderStatus = recommendationsContainer.querySelector('.loader-status');
                        cachedElements.loaderMessage = recommendationsContainer.querySelector('.loader-message');
                        cachedElements.statusIcon = recommendationsContainer.querySelector('.loader-status-icon');
                        
                        // Verify cache was populated (debug only)
                        if (!cachedElements.loaderElement || !cachedElements.progressFill) {
                            console.error('üîç updateDisplay: ERROR - Failed to cache elements after creation!');
                        } else {
                            console.log('üîç updateDisplay: Elements cached successfully - future updates will use cache');
                        }
                    };
                    
                    // Function to smoothly animate progress bar
                    const animateProgress = () => {
                        if (resolved) {
                            if (progressAnimationInterval) {
                                clearInterval(progressAnimationInterval);
                                progressAnimationInterval = null;
                            }
                            return;
                        }
                        
                        // Smoothly interpolate towards target
                        if (Math.abs(animatedProgress - targetProgress) > 0.5) {
                            const diff = targetProgress - animatedProgress;
                            animatedProgress += diff * 0.25; // Smooth interpolation (25% per frame)
                            if (animatedProgress > targetProgress) animatedProgress = targetProgress;
                        } else {
                            animatedProgress = targetProgress;
                        }
                        
                        // Don't call updateDisplay() here - it's called from elapsedTimer and job_status events
                        // This prevents flashing by avoiding too frequent DOM updates
                    };
                    
                    socket.on('subscribed', (msg) => {
                        console.log(`üì° Subscribed to job ${msg.job_id}`);
                        console.log(`üîç subscribed handler: recommendationsContainer=${!!recommendationsContainer}, typeof updateDisplay=${typeof updateDisplay}`);
                        console.log(`üîç subscribed handler: startTime=${startTime}, resolved=${resolved}`);
                        
                        currentStatus = { status: 'processing', progress: 0, message: 'Initializing analysis engine...' };
                        targetProgress = 2; // Start at 2% immediately
                        animatedProgress = 1; // Start at 1% for immediate visual feedback
                        
                        // Force immediate display update BEFORE starting intervals
                        console.log('üîç subscribed: About to call updateDisplay()');
                        try {
                            updateDisplay();
                            console.log('üîç subscribed: updateDisplay() called successfully');
                        } catch (error) {
                            console.error('üîç subscribed: ERROR calling updateDisplay():', error);
                        }
                        
                        // Start progress animation immediately (restart if needed)
                        if (progressAnimationInterval) {
                            clearInterval(progressAnimationInterval);
                        }
                        console.log('üîç subscribed: About to start progressAnimationInterval');
                        try {
                            progressAnimationInterval = setInterval(() => {
                                try {
                                    animateProgress();
                                } catch (error) {
                                    console.error('üîç animateProgress ERROR:', error);
                                }
                            }, 100); // Update every 100ms
                            console.log('üîç subscribed: progressAnimationInterval started');
                        } catch (error) {
                            console.error('üîç subscribed: ERROR starting progressAnimationInterval:', error);
                        }
                        
                        // Also call updateDisplay every second to ensure progress updates based on elapsed time
                        if (elapsedTimer) {
                            clearInterval(elapsedTimer);
                        }
                        console.log('üîç subscribed: About to start elapsedTimer');
                        try {
                            let lastUpdateTime = 0;
                            elapsedTimer = setInterval(() => {
                                if (!resolved) {
                                    try {
                                        const now = Date.now();
                                        // Only update if at least 2 seconds have passed since last update (throttle to reduce flashing)
                                        if (now - lastUpdateTime >= 2000) {
                                            lastUpdateTime = now;
                                            updateDisplay(); // Update every 2 seconds to show time-based progress
                                        }
                                    } catch (error) {
                                        console.error('üîç elapsedTimer: ERROR calling updateDisplay():', error);
                                    }
                                }
                            }, 1000); // Check every second, but only update every 2 seconds
                            console.log('üîç subscribed: elapsedTimer started (throttled to 2s updates)');
                        } catch (error) {
                            console.error('üîç subscribed: ERROR starting elapsedTimer:', error);
                        }
                    });
                    
                    socket.on('job_status', (statusData) => {
                        if (resolved) return;
                        
                        console.log(`üìä WebSocket update: Status = ${statusData.status}, Progress = ${statusData.progress || 0}%`);
                        console.log(`üîç job_status: About to update - targetProgress=${targetProgress}, animatedProgress=${animatedProgress}`);
                        
                        // Update current status with proper messages based on progress
                        let message = statusData.message || 'Analyzing deployment metrics and generating recommendations...';
                        if (statusData.status === 'processing') {
                            if (statusData.progress === 0) {
                                message = 'Initializing analysis engine...';
                            } else if (statusData.progress === 10) {
                                message = 'Collecting current metrics and forecast data...';
                            } else if (statusData.progress === 90) {
                                message = 'LLM analysis complete, processing results...';
                            } else if (statusData.progress < 10) {
                                message = 'Preparing data for analysis...';
                            } else if (statusData.progress < 90) {
                                message = 'Running LLM analysis...';
                            }
                        } else if (statusData.status === 'completed') {
                            message = 'Recommendations ready';
                        } else if (statusData.status === 'failed') {
                            message = statusData.error || 'Failed to generate recommendations';
                        }
                        
                        // Update target progress for smooth animation (always use the higher value)
                        const newProgress = statusData.progress || 0;
                        if (newProgress > targetProgress) {
                            targetProgress = newProgress;
                            console.log(`üîç job_status: Updated targetProgress to ${targetProgress}`);
                        }
                        
                        currentStatus = {
                            status: statusData.status,
                            progress: statusData.progress || 0,
                            message: message
                        };
                        
                        // Update display immediately
                        console.log(`üîç job_status: About to call updateDisplay()`);
                        try {
                            updateDisplay();
                            console.log(`üîç job_status: updateDisplay() called successfully`);
                        } catch (error) {
                            console.error(`üîç job_status: ERROR calling updateDisplay():`, error);
                        }
                        
                        if (statusData.status === 'completed') {
                            resolved = true;
                            if (elapsedTimer) {
                                clearInterval(elapsedTimer);
                                elapsedTimer = null;
                            }
                            if (progressAnimationInterval) {
                                clearInterval(progressAnimationInterval);
                                progressAnimationInterval = null;
                            }
                            targetProgress = 100;
                            animatedProgress = 100;
                            currentStatus = { status: 'completed', progress: 100, message: 'Recommendations ready' };
                            updateDisplay();
                            socket.emit('unsubscribe_job', { job_id: jobId });
                            socket.disconnect();
                            resolve(statusData.result);
                        } else if (statusData.status === 'failed') {
                            resolved = true;
                            if (elapsedTimer) {
                                clearInterval(elapsedTimer);
                                elapsedTimer = null;
                            }
                            if (progressAnimationInterval) {
                                clearInterval(progressAnimationInterval);
                                progressAnimationInterval = null;
                            }
                            currentStatus = { status: 'failed', progress: 0, message: 'Failed to generate recommendations. Please try again.' };
                            updateDisplay();
                            socket.emit('unsubscribe_job', { job_id: jobId });
                            socket.disconnect();
                            reject(new Error(statusData.error || 'Job failed'));
                        }
                    });
                    
                    socket.on('disconnect', () => {
                        console.log('üîå WebSocket disconnected');
                    });
                    
                    socket.on('connect_error', (error) => {
                        // Suppress WebSocket frame header errors (Cloudflare/proxy issue, non-critical)
                        const errorMsg = error?.message || String(error);
                        if (!errorMsg.includes('Invalid frame header') && !errorMsg.includes('frame')) {
                            console.error('‚ùå WebSocket connection error:', error);
                        }
                        if (!resolved) {
                            resolved = true;
                            if (elapsedTimer) clearInterval(elapsedTimer);
                            socket.disconnect();
                            // Fallback to polling
                            console.log('üîÑ Falling back to polling...');
                            fallbackToPolling(jobId).then(resolve).catch(reject);
                        }
                    });
                    
                    // Suppress WebSocket frame errors in console (Cloudflare/proxy issue)
                    const originalError = console.error;
                    console.error = function(...args) {
                        const errorStr = args.join(' ');
                        if (errorStr.includes('Invalid frame header') || errorStr.includes('WebSocket connection to')) {
                            // Suppress these non-critical errors
                            return;
                        }
                        originalError.apply(console, args);
                    };
                    
                    // Timeout after 4.5 minutes (270s) to accommodate Qwen's 240s timeout + buffer
                    setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            if (elapsedTimer) clearInterval(elapsedTimer);
                            if (progressAnimationInterval) clearInterval(progressAnimationInterval);
                            socket.emit('unsubscribe_job', { job_id: jobId });
                            socket.disconnect();
                            reject(new Error('WebSocket connection timeout - job may still be processing'));
                        }
                    }, 270000);
                    
                } catch (error) {
                    console.error('‚ùå WebSocket setup error:', error);
                    if (!resolved) {
                        resolved = true;
                        fallbackToPolling(jobId).then(resolve).catch(reject);
                    }
                }
            });
        } else {
            // Sync fallback (shouldn't happen with new endpoint, but handle gracefully)
            console.warn('‚ö†Ô∏è No job_id returned, treating as sync response');
            data = jobResponse;
        }
        
        if (!data) {
            throw new Error('No data received from job');
        }
        
        console.log(`üìä API response success:`, data.success, `error:`, data.error);
        
        // Check if API returned an error
        if (data.error && !data.success) {
            console.error(`‚ùå API returned error:`, data.error);
            throw new Error(data.error || 'Failed to get recommendations');
        }
        
        // Log target_replicas from API response for debugging
        if (data.recommendations?.predictive?.recommendation) {
            const rec = data.recommendations.predictive.recommendation;
            console.log(`üîçüîçüîç FRONTEND: Received target_replicas=${rec.target_replicas} from API, action=${rec.action}, scaling_type=${rec.scaling_type}`);
        }
        
        // Check if recommendations data exists
        if (!data.recommendations || !data.recommendations.predictive) {
            console.warn(`‚ö†Ô∏è No predictive recommendations in response:`, data);
            throw new Error('No recommendations data returned from API');
        }
        
        // Extract metrics for stability checking
        let currentMetrics = null;
        if (data.success && data.recommendations?.predictive) {
            const pred = data.recommendations.predictive;
            const forecast = pred.forecast || {};
            currentMetrics = {
                cpu: forecast.cpu?.current || 0,
                memory: forecast.memory?.current || 0,
                cpu_peak: forecast.cpu?.peak || 0,
                memory_peak: forecast.memory?.peak || 0
            };
        }
        
        // Update cache
        recommendationCache = {
            data: data,
            timestamp: Date.now(), // Use current time
            deployment: trimmedDeployment,
            namespace: trimmedNamespace,
            lastMetrics: currentMetrics
        };
        
        console.log(`‚úÖ Recommendation fetched and cached (will cache for ${RECOMMENDATION_CACHE_TTL/1000}s)`);
        
        displayRecommendations(data, chartContainer, recommendationsContainer);
    } catch (error) {
        console.error('‚ùå Error loading forecast:', error);
        const errorMsg = error.message || 'Unknown error';
        console.error('‚ùå Full error details:', {
            error: error,
            deployment: deployment,
            namespace: namespace,
            url: `/api/autoscaling/recommendations/${serverId}?deployment=${encodeURIComponent(deployment)}&namespace=${encodeURIComponent(namespace)}`
        });
        chartContainer.innerHTML = `<p class="text-muted text-center">Failed to load forecast: ${errorMsg}. <button onclick="manualRefresh()" class="btn btn-sm btn-primary mt-2">Retry</button></p>`;
        recommendationsContainer.innerHTML = `<p class="text-muted text-center">Failed to load recommendations: ${errorMsg}. <button onclick="manualRefresh()" class="btn btn-sm btn-primary mt-2">Retry</button></p>`;
    } finally {
        // Always clear loading flag
        isLoadingRecommendations = false;
    }
}

// Display recommendations function (extracted for reuse and stability)
function displayRecommendations(data, chartContainer, recommendationsContainer) {
    // Clear containers first to prevent duplicates
    if (chartContainer) chartContainer.innerHTML = '';
    if (recommendationsContainer) recommendationsContainer.innerHTML = '';
    
    if (data.success && data.recommendations?.predictive) {
        const pred = data.recommendations.predictive;
        const forecast = pred.forecast;
        
        // Create forecast chart (same as before)
        const ctx = chartContainer.getContext ? chartContainer.getContext('2d') : null;
        if (!ctx) {
            const canvas = document.createElement('canvas');
            chartContainer.innerHTML = '';
            chartContainer.appendChild(canvas);
            const newCtx = canvas.getContext('2d');
            if (charts.predictive) charts.predictive.destroy();
            charts.predictive = new Chart(newCtx, {
                type: 'line',
                data: {
                    labels: ['Now', '+1h', '+2h', '+3h', '+4h', '+5h', '+6h'],
                    datasets: [
                        {
                            label: 'CPU Forecast',
                            data: [forecast.cpu.current, ...(forecast.cpu.predictions || [])],
                            borderColor: 'rgb(37, 99, 235)',
                            backgroundColor: 'rgba(37, 99, 235, 0.1)',
                            tension: 0.4
                        },
                        {
                            label: 'Memory Forecast',
                            data: [forecast.memory.current, ...(forecast.memory.predictions || [])],
                            borderColor: 'rgb(16, 185, 129)',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            tension: 0.4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true, max: 100, title: { display: true, text: 'Usage (%)' } }
                    }
                }
            });
        } else {
            if (charts.predictive) charts.predictive.destroy();
            charts.predictive = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['Now', '+1h', '+2h', '+3h', '+4h', '+5h', '+6h'],
                    datasets: [
                        {
                            label: 'CPU Forecast',
                            data: [forecast.cpu.current, ...(forecast.cpu.predictions || [])],
                            borderColor: 'rgb(37, 99, 235)',
                            backgroundColor: 'rgba(37, 99, 235, 0.1)',
                            tension: 0.4
                        },
                        {
                            label: 'Memory Forecast',
                            data: [forecast.memory.current, ...(forecast.memory.predictions || [])],
                            borderColor: 'rgb(16, 185, 129)',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            tension: 0.4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true, max: 100, title: { display: true, text: 'Usage (%)' } }
                    }
                }
            });
        }
        
        // Show recommendations - prioritize LLM if available
        let rec = pred.recommendation;
        let isLLMRecommendation = false;
        
        if (pred.llm_used && rec.llm_recommendation) {
            rec = rec.llm_recommendation;
            isLLMRecommendation = true;
        } else if (data.recommendations?.llm?.success) {
            rec = data.recommendations.llm.recommendation;
            isLLMRecommendation = true;
        }
        
        // Determine action text and alert class (COLOR) - THIS IS THE KEY FIX
        let actionText = 'No Action';
        let alertClass = 'alert-success'; // GREEN - for maintain/no-action
        
        if (rec.action === 'scale_up') {
            actionText = 'Scale Up';
            alertClass = 'alert-warning'; // YELLOW/ORANGE
        } else if (rec.action === 'scale_down') {
            actionText = 'Scale Down';
            alertClass = 'alert-info'; // BLUE
        } else if (rec.action === 'at_max') {
            actionText = 'At Max Capacity';
            alertClass = 'alert-danger'; // RED
        } else if (rec.action === 'maintain' || rec.action === 'none') {
            actionText = 'Maintain Current';
            alertClass = 'alert-success'; // GREEN
        }
        
        // Get scaling type (HPA, VPA, both, or maintain)
        const scalingType = rec.scaling_type || 'hpa';  // Default to HPA for backward compatibility
        
        // Get current resource stats from recommendation data
        // The data structure is: data.recommendations.predictive contains current_resources, current_replicas, etc.
        const currentResources = pred.current_resources || {};
        const currentReplicas = pred.current_replicas || 0;
        const readyReplicas = pred.ready_replicas || 0;
        const availableReplicas = pred.available_replicas || 0;
        const currentMetrics = pred.current_metrics || {};
        
        // CRITICAL: Use forecast.current values (same as UI displays) instead of current_metrics
        // The UI displays forecast.cpu.current and forecast.memory.current, so the "Current Status" card
        // should also use these values for consistency
        const forecastCpu = forecast.cpu?.current ?? currentMetrics.cpu_usage ?? 0;
        const forecastMemory = forecast.memory?.current ?? currentMetrics.memory_usage ?? 0;
        
        console.log(`üîçüîçüîç FRONTEND METRICS: current_metrics.cpu=${currentMetrics.cpu_usage}, forecast.cpu.current=${forecast.cpu?.current}, using=${forecastCpu}`);
        console.log(`üîçüîçüîç FRONTEND METRICS: current_metrics.memory=${currentMetrics.memory_usage}, forecast.memory.current=${forecast.memory?.current}, using=${forecastMemory}`);
        
        // Build target information text with current stats
        let targetInfoText = '';
        
        // Show current pod/replica stats
        if (currentReplicas > 0) {
            targetInfoText += `<br><div style="margin-top: 0.5rem; padding: 0.75rem; background: #f8f9fa; border-radius: 0.25rem;"><strong>üìä Current Status:</strong>`;
            targetInfoText += `<br>&nbsp;&nbsp;‚Ä¢ Pods: ${currentReplicas} total, ${readyReplicas} ready, ${availableReplicas} available`;
            // Use forecast values (same as UI displays) instead of current_metrics
            targetInfoText += `<br>&nbsp;&nbsp;‚Ä¢ CPU Usage: ${forecastCpu.toFixed(1)}%`;
            targetInfoText += `<br>&nbsp;&nbsp;‚Ä¢ Memory Usage: ${forecastMemory.toFixed(1)}%`;
            targetInfoText += `</div>`;
        }
        
        // Show HPA target
        if (scalingType === 'hpa' || scalingType === 'both') {
            if (rec.target_replicas !== undefined && rec.target_replicas !== null) {
                targetInfoText += `<br><div style="margin-top: 0.5rem;"><strong>‚ÜîÔ∏è Horizontal Scaling (HPA):</strong>`;
                if (rec.calculated_replicas && rec.calculated_replicas > rec.target_replicas) {
                    targetInfoText += `<br>&nbsp;&nbsp;‚Ä¢ Current: ${currentReplicas} replicas`;
                    targetInfoText += `<br>&nbsp;&nbsp;‚Ä¢ Target: ${rec.target_replicas} replicas (Max reached)`;
                    targetInfoText += `<br>&nbsp;&nbsp;‚Ä¢ Recommended: ${rec.calculated_replicas} replicas (increase max_replicas)`;
                } else {
                    targetInfoText += `<br>&nbsp;&nbsp;‚Ä¢ Current: ${currentReplicas} replicas`;
                    targetInfoText += `<br>&nbsp;&nbsp;‚Ä¢ Target: ${rec.target_replicas} replicas`;
                }
                targetInfoText += `</div>`;
            }
        }
        
        // Show VPA target with current resources
        if (scalingType === 'vpa' || scalingType === 'both') {
            if (rec.target_cpu || rec.target_memory) {
                targetInfoText += `<br><div style="margin-top: 0.5rem;"><strong>üìä Vertical Scaling (VPA):</strong>`;
                
                // Show current resources if available
                if (currentResources.cpu_request || currentResources.memory_request) {
                    targetInfoText += `<br><strong>Current Resources:</strong>`;
                    targetInfoText += `<br>&nbsp;&nbsp;‚Ä¢ CPU Request: ${currentResources.cpu_request || 'N/A'}`;
                    targetInfoText += ` | Limit: ${currentResources.cpu_limit || 'N/A'}`;
                    targetInfoText += `<br>&nbsp;&nbsp;‚Ä¢ Memory Request: ${currentResources.memory_request || 'N/A'}`;
                    targetInfoText += ` | Limit: ${currentResources.memory_limit || 'N/A'}`;
                }
                
                // Show target resources
                targetInfoText += `<br><strong>Target Resources:</strong>`;
                if (rec.target_cpu) {
                    targetInfoText += `<br>&nbsp;&nbsp;‚Ä¢ CPU: ${rec.target_cpu}`;
                    if (currentResources.cpu_request && currentResources.cpu_request !== 'N/A') {
                        const currentCpu = parseFloat(currentResources.cpu_request.replace('m', '')) || 0;
                        const targetCpu = parseFloat(rec.target_cpu.replace('m', '')) || 0;
                        if (targetCpu > currentCpu) {
                            targetInfoText += ` <span style="color: #10b981;">‚Üë +${((targetCpu - currentCpu) / currentCpu * 100).toFixed(0)}%</span>`;
                        } else if (targetCpu < currentCpu) {
                            targetInfoText += ` <span style="color: #ef4444;">‚Üì ${((targetCpu - currentCpu) / currentCpu * 100).toFixed(0)}%</span>`;
                        }
                    }
                }
                if (rec.target_memory) {
                    targetInfoText += `<br>&nbsp;&nbsp;‚Ä¢ Memory: ${rec.target_memory}`;
                    if (currentResources.memory_request && currentResources.memory_request !== 'N/A') {
                        // Simple comparison (could be improved with proper unit conversion)
                        const currentMem = currentResources.memory_request;
                        const targetMem = rec.target_memory;
                        if (targetMem !== currentMem) {
                            targetInfoText += ` <span style="color: #10b981;">(from ${currentMem})</span>`;
                        }
                    }
                }
                targetInfoText += `</div>`;
            }
        }
        
        // Get deployment info - try multiple sources
        let deploymentName = '';
        let namespace = 'default';
        
        // Try to get from recommendation data
        if (data.deployment) {
            deploymentName = data.deployment;
            namespace = data.namespace || 'default';
        }
        // Try to get from current recommendation cache
        else if (recommendationCache.deployment) {
            deploymentName = recommendationCache.deployment;
            namespace = recommendationCache.namespace || 'default';
        }
        // Fallback: get from first enabled deployment
        else {
            // This will be set when loadPredictiveForecast is called with deployment/namespace
            // For now, we'll get it from the global scope if available
            const firstDeployment = window.currentPredictiveDeployment;
            if (firstDeployment) {
                deploymentName = firstDeployment.deployment_name;
                namespace = firstDeployment.namespace || 'default';
            }
        }
        
        // Build recommendation HTML
        let recommendationHTML = '';
        
        // Initialize targetReplicasText early to avoid undefined errors
        let targetReplicasText = '';
        
        // Add "Apply Recommendation" button if we have valid targets
        let applyButtonHTML = '';
        const hasHpaTarget = (scalingType === 'hpa' || scalingType === 'both') && 
                            rec.target_replicas !== undefined && rec.target_replicas !== null;
        const hasVpaTarget = (scalingType === 'vpa' || scalingType === 'both') && 
                            (rec.target_cpu || rec.target_memory);
        
        if (rec.action &&
            rec.action !== 'none' &&
            deploymentName &&
            (hasHpaTarget || hasVpaTarget)) {

            // Build button text based on scaling type
            let buttonText = 'Apply Recommendation';
            if (scalingType === 'hpa') {
                buttonText = `Apply HPA (${rec.target_replicas} replicas)`;
            } else if (scalingType === 'vpa') {
                buttonText = `Apply VPA (CPU: ${rec.target_cpu || 'N/A'}, Memory: ${rec.target_memory || 'N/A'})`;
            } else if (scalingType === 'both') {
                buttonText = `Apply HPA + VPA`;
            }

            applyButtonHTML = `
                <div style="margin-top: 1rem; text-align: right;">
                    <button class="btn btn-primary"
                        onclick="applyPredictiveRecommendation('${deploymentName}', '${namespace}', ${rec.target_replicas || 'null'}, '${rec.target_cpu || ''}', '${rec.target_memory || ''}', '${scalingType}')"
                        style="min-width: 150px;">
                        <i class="fas fa-check-circle"></i> ${buttonText}
                    </button>
                </div>
            `;
        }
        
        if (isLLMRecommendation) {
            const confidence = (rec.confidence || 0) * 100;
            const scalingTypeBadge = scalingType === 'vpa' ? 'üìä VPA' : scalingType === 'both' ? 'üîÑ HPA+VPA' : '‚ÜîÔ∏è HPA';
            recommendationHTML += `
                <div class="alert ${alertClass}" style="border-left: 4px solid #8b5cf6;">
                    <div style="display: flex; align-items: center; margin-bottom: 0.5rem;">
                        <strong style="flex: 1;">ü§ñ LLM-Powered Recommendation: ${actionText} ${scalingTypeBadge}</strong>
                        <span class="badge" style="background: ${confidence > 70 ? '#10b981' : confidence > 40 ? '#f59e0b' : '#ef4444'}; color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem;">
                            ${confidence.toFixed(0)}% Confidence
                        </span>
                    </div>
                    <div style="margin-top: 0.75rem;">
                        <strong>Reasoning:</strong>
                        <p style="margin: 0.5rem 0; white-space: pre-wrap;">${rec.reasoning || rec.reason || 'No reasoning provided'}</p>
                    </div>
                    ${targetInfoText}
                    ${applyButtonHTML}
                </div>
            `;
        } else {
            // Build target info for non-LLM recommendations
            if (rec.target_replicas !== undefined && rec.target_replicas !== null) {
                console.log(`üîçüîçüîç FRONTEND DISPLAY: Setting targetReplicasText to ${rec.target_replicas}`);
                targetReplicasText = `<br><strong>Target Replicas:</strong> ${rec.target_replicas}`;
            } else {
                console.log(`üîçüîçüîç FRONTEND DISPLAY: target_replicas is ${rec.target_replicas} (undefined/null)`);
            }
            
            recommendationHTML = `
                <div class="alert ${alertClass}">
                    <strong>Recommendation:</strong> ${actionText}
                    <br><small>${rec.reason || 'No specific recommendation'}</small>
                    ${targetReplicasText}
                    ${applyButtonHTML}
                </div>
            `;
        }
        
        recommendationsContainer.innerHTML = recommendationHTML;
    } else {
        chartContainer.innerHTML = '<div class="alert alert-warning">No forecast data available</div>';
        recommendationsContainer.innerHTML = '<div class="alert alert-info">No recommendations available. Enable predictive autoscaling to get recommendations.</div>';
    }
}

// Load scaling history
async function loadScalingHistory() {
    const container = document.getElementById('scaling-history-chart');
    if (!container) {
        console.error('‚ùå scaling-history-chart container not found');
        return;
    }
    
    try {
        // For now, show a placeholder chart
        // In the future, this could show actual scaling history from the API
        const canvas = document.createElement('canvas');
        container.innerHTML = '';
        container.appendChild(canvas);
        
        if (charts.history) charts.history.destroy();
        
        // Create a sample chart
        charts.history = new Chart(canvas.getContext('2d'), {
            type: 'line',
            data: {
                labels: ['1h ago', '2h ago', '3h ago', '4h ago', '5h ago', '6h ago', 'Now'],
                datasets: [
                    {
                        label: 'Replicas',
                        data: [2, 2, 3, 3, 2, 2, 2],
                        borderColor: 'rgb(37, 99, 235)',
                        backgroundColor: 'rgba(37, 99, 235, 0.1)',
                        tension: 0.4
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: { beginAtZero: true, title: { display: true, text: 'Replicas' } }
                }
            }
        });
    } catch (error) {
        console.error('Error loading scaling history:', error);
        container.innerHTML = '<p class="text-muted text-center">Failed to load scaling history.</p>';
    }
}

// Create Schedule
async function createSchedule(event) {
    event.preventDefault();
    const form = event.target;
    const data = {
        deployment_name: document.getElementById('schedule-deployment').value,
        namespace: document.getElementById('schedule-namespace').value,
        schedule_rules: [{
            time: document.getElementById('schedule-time').value,
            replicas: parseInt(document.getElementById('schedule-replicas').value),
            reason: 'Manual schedule'
        }]
    };
    
    try {
        const response = await fetch(`/api/autoscaling/schedule/create/${serverId}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(data)
        });
        const result = await response.json();
        
        if (result.success) {
            alert('Schedule created successfully!');
            form.reset();
            refreshAutoscaling();
        } else {
            alert('Error: ' + (result.error || 'Failed to create schedule'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// Analyze patterns
async function analyzePatterns() {
    const deployment = prompt('Enter deployment name:');
    if (!deployment) return;
    
    try {
        const response = await fetch(`/api/autoscaling/patterns/${serverId}?deployment=${deployment}`);
        const data = await response.json();
        
        if (data.success) {
            alert('Pattern analysis complete! Check recommendations.');
            console.log('Pattern recommendations:', data.recommendations);
        } else {
            alert('Error: ' + (data.error || 'Failed to analyze patterns'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// Delete HPA
async function deleteHPA(hpaName, namespace) {
    if (!confirm(`Are you sure you want to delete HPA "${hpaName}"?`)) {
        return;
    }
    
    try {
        const response = await fetch(`/api/autoscaling/hpa/delete/${serverId}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                hpa_name: hpaName,
                namespace: namespace
            })
        });
        const result = await response.json();
        
        if (result.success) {
            alert('HPA deleted successfully!');
            refreshAutoscaling();
        } else {
            alert('Error: ' + (result.error || 'Failed to delete HPA'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// Disable Predictive Autoscaling
async function disablePredictiveAutoscaling(deploymentName, namespace) {
    if (!confirm(`Are you sure you want to disable predictive autoscaling for "${deploymentName}"?`)) {
        return;
    }
    
    try {
        const response = await fetch(`/api/autoscaling/predictive/disable/${serverId}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                deployment_name: deploymentName,
                namespace: namespace
            })
        });
        const result = await response.json();
        
        if (result.success) {
            alert('Predictive autoscaling disabled successfully!');
            refreshAutoscaling();
            // Clear recommendations cache
            recommendationCache = { data: null, timestamp: 0, deployment: null, namespace: null, lastMetrics: null };
            lastRecommendationFetchTime = 0;
            // Clear displayed recommendations
            const recommendationsContainer = document.getElementById('predictive-recommendations');
            if (recommendationsContainer) {
                recommendationsContainer.innerHTML = '<p class="text-muted text-center">No recommendations available. Enable predictive autoscaling to get recommendations.</p>';
            }
            const chartContainer = document.getElementById('predictive-forecast-chart');
            if (chartContainer) {
                chartContainer.innerHTML = '<p class="text-muted text-center">No forecast data available. Enable predictive autoscaling for a deployment to see forecasts.</p>';
            }
        } else {
            alert('Error: ' + (result.error || 'Failed to disable predictive autoscaling'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// Delete Schedule
async function deleteSchedule(deploymentName, namespace) {
    if (!confirm(`Are you sure you want to delete the schedule for "${deploymentName}"?`)) {
        return;
    }
    
    try {
        const response = await fetch(`/api/autoscaling/schedule/delete/${serverId}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                deployment_name: deploymentName,
                namespace: namespace
            })
        });
        const result = await response.json();
        
        if (result.success) {
            alert('Schedule deleted successfully!');
            refreshAutoscaling();
        } else {
            alert('Error: ' + (result.error || 'Failed to delete schedule'));
        }
    } catch (error) {
        alert('Error: ' + error.message);
    }
}

// Apply Predictive Recommendation (force apply target replicas)
async function applyPredictiveRecommendation(deploymentName, namespace, targetReplicas, targetCpu, targetMemory, scalingType) {
    // Build confirmation message based on scaling type
    let confirmMsg = '';
    if (scalingType === 'hpa' || scalingType === 'both') {
        confirmMsg += `Scale "${deploymentName}" to ${targetReplicas} replicas (HPA)`;
    }
    if (scalingType === 'vpa' || scalingType === 'both') {
        if (confirmMsg) confirmMsg += ' and ';
        confirmMsg += `set resources to CPU: ${targetCpu}, Memory: ${targetMemory} (VPA)`;
    }
    
    if (!confirm(`Apply recommendation: ${confirmMsg}?`)) {
        return;
    }
    
    try {
        // Trim deployment name to remove any whitespace
        const trimmedDeploymentName = deploymentName.trim();
        console.log(`üîÑ Applying recommendation: ${trimmedDeploymentName} -> Scaling Type: ${scalingType}`);
        if (scalingType === 'hpa' || scalingType === 'both') {
            console.log(`  HPA: ${targetReplicas} replicas`);
        }
        if (scalingType === 'vpa' || scalingType === 'both') {
            console.log(`  VPA: CPU=${targetCpu}, Memory=${targetMemory}`);
        }
        
        const response = await fetch(`/api/autoscaling/predictive/apply/${serverId}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                deployment_name: trimmedDeploymentName,
                namespace: namespace || 'default',
                target_replicas: targetReplicas !== null && targetReplicas !== undefined ? parseInt(targetReplicas) : null,
                target_cpu: targetCpu || null,
                target_memory: targetMemory || null,
                scaling_type: scalingType || 'hpa'
            })
        });
        const result = await response.json();
        
        console.log('üìä Apply recommendation response:', result);
        
        if (result.success) {
            // Use backend message if available, otherwise build one
            let successMsg = result.message || '';
            if (!successMsg) {
                if (scalingType === 'hpa' || scalingType === 'both') {
                    successMsg += `Scaled to ${targetReplicas} replicas. `;
                }
                if (scalingType === 'vpa' || scalingType === 'both') {
                    successMsg += `Set resources to CPU: ${targetCpu}, Memory: ${targetMemory}. `;
                }
            }
            // Note: We no longer patch HPAs - Predictive Autoscaling scales independently
            if (result.hpa_exists && !result.hpa_modified) {
                successMsg += ' (HPA exists but was not modified - consider deleting HPA to avoid conflicts)';
            }
            alert(successMsg.trim());
            
            // Wait 2 seconds for Kubernetes to apply the changes before refreshing
            console.log('‚è≥ Waiting 2 seconds for Kubernetes to apply changes...');
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Refresh to show updated replica count
            await refreshAutoscaling(false);
        } else {
            let errorMsg = result.error || 'Failed to apply recommendation';
            // Check if VPA is not installed
            if (result.vpa_not_installed) {
                errorMsg += '\n\nVPA (Vertical Pod Autoscaler) is not installed in your cluster. To use VPA recommendations, you need to install the VPA controller first.\n\nInstallation guide: https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler';
            }
            alert('Error: ' + errorMsg);
            console.error('‚ùå Apply recommendation failed:', result);
        }
    } catch (error) {
        alert('Error: ' + error.message);
        console.error('‚ùå Exception in applyPredictiveRecommendation:', error);
    }
}

// Track if initial load has happened
let initialLoadComplete = false;

// Initial load - only fetch recommendations once
refreshAutoscaling().then(() => {
    initialLoadComplete = true;
    console.log('‚úÖ Initial page load complete - recommendations will NOT auto-refresh');
}).catch(error => {
    console.error('‚ùå Error in initial refreshAutoscaling:', error);
    initialLoadComplete = true; // Set anyway to prevent blocking
});

// Load scaling history
loadScalingHistory().catch(error => {
    console.error('‚ùå Error loading scaling history:', error);
});

// Debounced refresh function
let refreshTimeout = null;
function debouncedRefresh() {
    if (refreshTimeout) clearTimeout(refreshTimeout);
    refreshTimeout = setTimeout(() => {
        refreshAutoscaling();
    }, 5000); // Wait 5 seconds after last call
}

// Track refresh interval to prevent multiple intervals
let refreshIntervalId = null;

// Clear any existing interval
if (refreshIntervalId) {
    clearInterval(refreshIntervalId);
}

// Refresh every 120 seconds (2 minutes) - updates overview stats only
// NOTE: Recommendations are NOT auto-refreshed - they use 5-minute cache and rate limiting
// Users must manually refresh or wait for cache to expire
refreshIntervalId = setInterval(() => {
    // Only refresh if page is visible and not currently loading recommendations
    // IMPORTANT: This ONLY updates overview stats (HPA count, etc.), NOT recommendations
    if (!document.hidden && !isLoadingRecommendations && initialLoadComplete) {
        console.log('üîÑ Auto-refreshing autoscaling STATUS ONLY (HPA count, schedules, etc.) - NOT recommendations');
        // Refresh status but DON'T trigger recommendation loading
        // We'll manually fetch status without calling loadPredictiveForecast
        fetch(`/api/autoscaling/status/${serverId}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update overview stats only
                    document.getElementById('hpa-count').textContent = data.hpa_count || 0;
                    document.getElementById('predictive-enabled').textContent = data.predictive_count || 0;
                    document.getElementById('scheduled-count').textContent = data.schedule_count || 0;
                    document.getElementById('vpa-count').textContent = data.vpa_count || 0;
                    // Use backend-calculated total_replicas if available, otherwise sum HPAs
                    let totalReplicas = 0;
                    if (data.total_replicas !== undefined) {
                        totalReplicas = data.total_replicas;
                    } else {
                        totalReplicas = (data.hpas || []).reduce((sum, hpa) => sum + (hpa.current_replicas || 0), 0);
                    }
                    document.getElementById('total-replicas').textContent = totalReplicas;
                    // Update lists for consistency, but DO NOT touch recommendations
                    updateHPAList(data.hpas || []);
                    updateScheduleList(data.schedules || []);
                    updatePredictiveDeploymentsList(data.predictive_deployments || []);
                    updateVPAList(data.vpas || []);
                    // DO NOT call loadPredictiveForecast - recommendations stay as-is
                }
            })
            .catch(error => console.error('Error refreshing status:', error));
    }
}, 120000); // 120 seconds (2 minutes) - for overview stats only, NOT recommendations
</script>
{% endblock %}

